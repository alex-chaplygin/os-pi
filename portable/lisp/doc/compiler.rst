Компилятор Lisp
==============================

Фаза 1 - Статический анализ и компиляция исходного дерева
---------------------------------------------------------

Исходное S-выражение преобразуется в другое S-выражение, состоящее из простых операций.

Константы остаются без изменений.

Для переменных вычисляется лексическое окружение в момент обращения к ним. В результирующей программе вместо окружений будут создаваться записи активаций. Окружение состоит из кадров, в каждом находится список связанных лексических переменных. Новый кадр создается только при вызове функции, предыдущее окружение восстанавливается после выхода из функции, начальное лексическое окружение пустое.

Глобальные переменные создаются при присваивании и сохраняются с списке \*global-variables\*.

При компиляции переменных определяется тип переменной: локальная, глобальная, свободная. Для локальных переменных вычисляется смещение в текущем кадре, для глобальных - индекс в списке глобальных переменных. Для свободных переменных вычисляются два смещения - смещение на кадр, где расположена свободная переменная, относительно текущего кадра, и смещение внутри кадра. Таким образом в результате компиляции все переменные статически разрешаются, при выполнении не будет их поиска.

Последовательности выражений (progn) компилируются в древовидную последовательность, для одиночных выражений progn убирается.

В условной форме if анализируются и компилируются все три аргумента, результаты передаются в форму ALTER.

При компиляции присваиваний также как и при обращении к переменным определяется тип переменной и компилируются выражения для присваивания.

Пользовательские функции компилируются также как и лямбда-функции, в глобальную таблицу функций \*global-functions\* сохраняются имена функций, смещение кадра окружения, в котором определяется функция, число их аргументов, которое используется для проверки при применении функции. Для лямбда функций имена генерируются.

При компиляции применения функции, определяется тип функции: глобальная, лямбда или примитив. Происходит проверка числа аргументов. Для лямбда функций перед вызовом вставляется скомпилированное тело функции. Перед вызовом функции активируется замкнутое окружение функции, создается кадр активации с заранее вычисленным размером, вычисляются слева направо аргументы, и заносятся в текущий кадр. При вызове примитивов кадр активации не создается.

Операции после первой фазы:

:CONST expr: Выражение константа.
:LOCAL-REF j: Обращение к j-той локальной переменной.
:GLOBAL-REF i: Обращение к i-той глобальной переменной.
:DEEP-REF i j: Обращение к дальней свободной переменной.
	       i - смещение кадра активации, j - позиция в кадре.
:SEQ <expr list>: Последовательность вычислений списка выражений.
:ALTER cond true false: Условный оператор с выражениями условия, истины и лжи.
:LOCAL-SET j expr: Присваивание выражения в j-тую локальную переменную.
:GLOBAL-SET i expr: Присваивание выражения в i-тую глобальную переменную.
:DEEP-SET i j expr: Присваивание выражения в дальнюю свободную переменную.
	       i - смещение кадра активации, j - позиция в кадре.
:LABEL lab expr: Выражение с меткой.
:FIX-LET num args expr: let форма, num - число аргументов, args - список выражений аргументов, expr - тело lambda
:FIX-CLOSURE name body: Замыкание функции с именем name и телом body.
:RETURN: Выход из функции.
:REG-CALL name env args: Вызов функции с именем name, номером окружения ofs и списком выражений аргументов args.
:PRIM name args: Вызов примитива с именем name и списком выражений аргументов args.
:NOP: Нет операции

Фаза 2 - Генерация линейных инструкций
--------------------------------------

Дерево, полученное на этапе компиляции, преобразуетс в ассемблер код - список инструкций с мнемониками вместо опкодов. Для этого элементы дерева, начиная с самого верхнего, рекурсивно генерируются определённым образом.

Инструкции после генерации:

:CONST val: Записать val в аккумулятор.
:LOCAL-REF j: Записать j-тую локальную переменную в аккумулятор.
:GLOBAL-REF i: Записать i-тую глобальную переменную в аккумулятор.
:DEEP-REF i j: Записать дальнюю свободную переменную в аккумулятор.
	       i - смещение кадра активации, j - позиция в кадре.
:LOCAL-SET j: Записать значение аккумулятора в j-тую локальную переменную.
:GLOBAL-SET i: Записать значение аккумулятора в i-тую глобальную переменную.
:DEEP-SET i j: Записать значение аккумулятора в дальнюю свободную переменную.
	       i - смещение кадра активации, j - позиция в кадре.
:PUSH i: Помещаем аккумулятор в стек, i - игнорируется.
:POP: Извлекаем значение из стека и записываем в аккумулятор.
:LABEL name: Символьная метка.
:JMP label: Безусловный переход на метку.
:JNT label: Переход на метку если в аккумуляторе nil.
:ALLOC n: Создать новый кадр активации с размером n.
:REG-CALL name: Вызов функции с меткой name.
:SET-ENV num: Сохранить текущий кадр активации в стеке.
	      Установить кадр активации с позицией num от начала списка кадров.
:RESTORE-ENV: Восстановить кадр активации из стека.
:FIX-CLOSURE name: Создать замыкание с текущим кадром активации,
		   кодом по метке name, записать замыкание в аккумулятор.
:RETURN: Выход из функции.

Для элементов CONST, GLOBAL-REF, LOCAL-REF, DEEP-REF и RETURN существуют соответствующие инструкции, поэтому они генерируются как инструкции с мнемониками и операндами без изменений.

Для элементов GLOBAL-SET, LOCAL-SET и DEEP-SET сначала генерируется вычисление их аргументов, при этом идёт симуляция глобальных переменных и окружения, чтобы затем эти инструкции можно было сгенерировать с правильными аргументами.

Элемент LABEL используется для генерации тела функции, поэтому сначала рассчитывается метка после тела функции, генерируется переход на эту метку, после этого генерируется тело самой функции, и в конце добавляется эта метка.

Элемент FIX-CLOSURE на данный момент игнорируется генератором; рекурсивно генерируется тело данного элемента.

В элементе SEQ для каждого дочернего элемента рекурсивно по очереди происходит дальнейшая генерация.

Для элемента ALTER рассчитываются метки для ветки по лжи и для конца if-блока, затем генерируется условие, условный переход на ветку по лжи, тело по истине и безусловный переход на конец блока, метка и тело по лжи, и метка конца блока.

В элементе PRIM для каждого аргумента генерируется вычисление этого аргумента и инструкция PUSH, затем генерируется вызов соответствующего примитива.

Для элемента REG-CALL генерируется установление соответствующего окружения для текущей функции (SET-ENV), создание кадра активации (ALLOC), генерация вычисления и добавления в окружение аргументов функции, вызов самой функции (REG-CALL) и в конце восстановление окружения (RESTORE-ENV).

Фаза 3 - Ассемблер.
-------------------

Последним шагом компиляции является генерация байт-кода из ассемблер-кода. Ассемблирование происходит в 2 прохода.

При первом проходе мнемоники опкодов заменяются соответствующими байтами опкодов, при этом если встречается метка, то она не добавляется в результирующий байт-код, но запоминается в хеш-таблицу c адресом следующей инструкции, и если встречается инструкция перехода, то в отдельный список добавляется текущий адрес с меткой, которую использует данная инструкция.

Второй проход идёт по списку адресов с метками и в байт-коде заменяется соответствующие метки на адреса меток из хеш-таблицы.

Виртуальная машина
------------------------------

Точка входа виртуальной машины - функция vm-run:

::

  (vm-run program)
    program - байт-код (массив инструкций).

В байт-коде каждый байт - опкод или операнд инструкции.

Функция последовательно выполняет инструкции и возвращает значение регистра ACC в результате выполнения байт-кода.

Архитектура виртуальной машины
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- PC - хранит адрес текущей выполняемой инструкции.
- ACC - хранит результат последней операции. Может быть любым объектом.
- GLOBALS-MEM - содержит данные для глобальных переменных; массив.
- STACK - стэк общего назначения; массив.
- ENV - окружение для функций.
- ENV-NUM - номер глубины текущего кадра окружения.

Список инструкций
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- CONST expr - поместить expr в регистр ACC.
- JMP addr - безусловный переход на addr относительно PC.
- JNT addr - если ACC != T, то относительный переход на addr.
- GLOBAL-REF i - устанавливает регистру ACC значение глобальной переменной из массива GLOBALS-MEM с индексом i.
- GLOBAL-SET i - устанавливает глобальной переменной из массива GLOBALS-MEM с индексом i значение регистра ACC.
- LOCAL-REF i - загружает в ACC значение i локальной переменной (текущего кадра активации в окружении).
- LOCAL-SET i - присваивает локальной переменной i (текущего кадра активации в окружении) значение регистра ACC.
- DEEP-REF i j - загружает в ACC значение локальной переменной с индексом j в кадре i.
- DEEP-SET i j - присваивает локальной переменной j в кадре i значение регистра ACC.
- PUSH - добавляет значение регистра ACC в стэк.
- REG-CALL addr - добавляет адрес следующей инструкции в стэк и производит переход на относительный адрес addr.
- RETURN - производит переход на адрес из верхушки стэка, при этом удаляет этот адрес из стэка.
- SET-ENV num - сохраняет текущий кадр окружения в стек и производит переход окружения на кадр с номером num.
- RESTORE-ENV - восстанавливает окружение из стека.
- PRIM1 - вызывает примитив от 1 аргумента по индексу i в таблице примитивов \*prim1-table\*.
- PRIM2 - вызывает примитив от 2 аргументов по индексу i в таблице примитивов \*prim2-table\*.
- PRIM3 - вызывает примитив от 3 аргументов по индексу i в таблице примитивов \*prim3-table\*.
