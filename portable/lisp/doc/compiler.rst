Компилятор Lisp
==============================

Фаза 1 - Статический анализ и компиляция исходного дерева
---------------------------------------------------------

Исходное S-выражение преобразуется в другое S-выражение, состоящее из простых операций.

Константы остаются без изменений.

Для переменных вычисляется лексическое окружение в момент обращения к ним. В результирующей программе вместо окружений будут создаваться записи активаций. Окружение состоит из кадров, в каждом находится список связанных лексических переменных. Новый кадр создается только при вызове функции, предыдущее окружение восстанавливается после выхода из функции, начальное лексическое окружение пустое.

Глобальные переменные создаются при присваивании и сохраняются с списке \*global-variables\*.

При компиляции переменных определяется тип переменной: локальная, глобальная, свободная. Для локальных переменных вычисляется смещение в текущем кадре, для глобальных - индекс в списке глобальных переменных. Для свободных переменных вычисляются два смещения - смещение на кадр, где расположена свободная переменная, относительно текущего кадра, и смещение внутри кадра. Таким образом в результате компиляции все переменные статически разрешаются, при выполнении не будет их поиска.

Последовательности выражений (progn) компилируются в древовидную последовательность, для одиночных выражений progn убирается.

В условной форме if анализируются и компилируются все три аргумента, результаты передаются в форму ALTER.

При компиляции присваиваний также как и при обращении к переменным определяется тип переменной и компилируются выражения для присваивания.

Пользовательские функции с фиксированным числом аргументов компилируются также как и лямбда-функции, в глобальную таблицу функций \*fix-functions\* сохраняются имена функций, смещение кадра окружения, в котором определяется функция, число их аргументов, которое используется для проверки при применении функции. Для лямбда функций имена генерируются.

Функции с переменным числом аргументов сохраняются в таблицу \*nary-functions\*, где хранятся имена функций, смещение кадра окружения и число фиксированных аргументов (остальные аргументы будут в добавленном списке).

При компиляции формы labels, расширяется окружение локальных функций, где сохраняется локальное имя функции и сгенерированное имя функции, затем генерируется код функций, после чего окружение возвращается к предыдущему состоянию.

Примитивы с фиксированным числом аргументов хранятся в таблице \*fix-primitives\*, хранится имя примитива и число аргументов.

Примитивы с переменным числом аргументов хранятся в таблице \*nary-primitives\*, хранится имя примитива и число фиксированных аргументов.

При компиляции применения функции, определяется тип функции: глобальная, лямбда или примитив. Происходит проверка числа аргументов. Для лямбда функций перед вызовом вставляется скомпилированное тело функции. Перед вызовом функции активируется замкнутое окружение функции, создается кадр активации с заранее вычисленным размером, вычисляются слева направо аргументы, и заносятся в текущий кадр. При вызове примитивов кадр активации не создается.

Операции после первой фазы:

:CONST expr: Выражение константа.
:LOCAL-REF j: Обращение к j-той локальной переменной.
:GLOBAL-REF i: Обращение к i-той глобальной переменной.
:DEEP-REF i j: Обращение к дальней свободной переменной.
	       i - смещение кадра активации, j - позиция в кадре.
:SEQ <expr list>: Последовательность вычислений списка выражений.
:ALTER cond true false: Условный оператор с выражениями условия, истины и лжи.
:LOCAL-SET j expr: Присваивание выражения в j-тую локальную переменную.
:GLOBAL-SET i expr: Присваивание выражения в i-тую глобальную переменную.
:DEEP-SET i j expr: Присваивание выражения в дальнюю свободную переменную.
	       i - смещение кадра активации, j - позиция в кадре.
:LABEL lab expr: Выражение с меткой.
:FIX-LET num args expr: let форма, num - число аргументов, args - список выражений аргументов, expr - тело lambda
:FIX-CLOSURE name body: Замыкание функции (фиксированное число аргументов) с именем name и телом body.
:RETURN: Выход из функции.
:FIX-CALL name env args: Вызов функции с именем name, номером окружения ofs и списком выражений аргументов args (фиксированное число аргументов).
:NARY-CALL name num env args: Вызов функции с именем name, номером окружения ofs и списком выражений аргументов args (переменное число аргументов).
			      num - число фиксированных аргументов.
:FIX-PRIM name args: Вызов примитива (фиксированное число аргументов) с именем name и списком выражений аргументов args.
:NARY-PRIM name num args: Вызов примитива (переменное число аргументов) с именем name, числом фиксированных аргументов num и списком выражений аргументов args.
:NOP: Нет операции

Фаза 2 - Генерация линейных инструкций
--------------------------------------

Дерево, полученное на этапе компиляции, преобразуетс в ассемблер код - список инструкций с мнемониками вместо опкодов. Для этого элементы дерева, начиная с самого верхнего, рекурсивно генерируются определённым образом.

Инструкции после генерации:

:CONST val: Записать val в аккумулятор.
:LOCAL-REF j: Записать j-тую локальную переменную в аккумулятор.
:GLOBAL-REF i: Записать i-тую глобальную переменную в аккумулятор.
:DEEP-REF i j: Записать дальнюю свободную переменную в аккумулятор.
	       i - смещение кадра активации, j - позиция в кадре.
:LOCAL-SET j: Записать значение аккумулятора в j-тую локальную переменную.
:GLOBAL-SET i: Записать значение аккумулятора в i-тую глобальную переменную.
:DEEP-SET i j: Записать значение аккумулятора в дальнюю свободную переменную.
	       i - смещение кадра активации, j - позиция в кадре.
:PUSH i: Помещаем аккумулятор в стек, i - игнорируется.
:POP: Извлекаем значение из стека и записываем в аккумулятор.
:LABEL name: Символьная метка.
:JMP label: Безусловный переход на метку.
:JNT label: Переход на метку если в аккумуляторе nil.
:ALLOC n: Создать новый кадр активации с размером n.
	  Записать туда значения из стека в обратном порядке.
:PRIM name: Вызов примитива с именем name.
:PACK n: Упаковка n верхних элементов в стеке в список.
	 Если n равен 0, то добавляет пустой список в стек.
:REG-CALL name: Вызов функции с меткой name.
:SAVE-ENV: Сохранить текущий кадр активации в стеке.
:SET-ENV num: Установить кадр активации с позицией num от начала списка кадров.
:RESTORE-ENV: Восстановить кадр активации из стека.
:FIX-CLOSURE name: Создать замыкание с текущим кадром активации,
		   кодом по метке name, записать замыкание в аккумулятор.
:RETURN: Выход из функции.

Для элементов CONST, GLOBAL-REF, LOCAL-REF, DEEP-REF и RETURN существуют соответствующие инструкции, поэтому они генерируются как инструкции с мнемониками и операндами без изменений.

Для элементов GLOBAL-SET, LOCAL-SET и DEEP-SET сначала генерируется вычисление их аргументов, при этом идёт симуляция глобальных переменных и окружения, чтобы затем эти инструкции можно было сгенерировать с правильными аргументами.

Элемент LABEL используется для генерации тела функции, поэтому сначала рассчитывается метка после тела функции, генерируется переход на эту метку, после этого генерируется тело самой функции, и в конце добавляется эта метка.

Элемент FIX-CLOSURE на данный момент игнорируется генератором; рекурсивно генерируется тело данного элемента.

В элементе SEQ для каждого дочернего элемента рекурсивно по очереди происходит дальнейшая генерация.

Для элемента ALTER рассчитываются метки для ветки по лжи и для конца if-блока, затем генерируется условие, условный переход на ветку по лжи, тело по истине и безусловный переход на конец блока, метка и тело по лжи, и метка конца блока.

В элементе FIX-PRIM для каждого аргумента генерируется вычисление этого аргумента и инструкция PUSH, затем генерируется вызов соответствующего примитива PRIM.

В элементе NARY-PRIM для каждого аргумента генерируется вычисление этого аргумента и инструкция PUSH, необязательные аргументы собираются в список с помощью команды PACK (удаляются из стека и добавляются как список), затем генерируется вызов соответствующего примитива PRIM.

Для элемента REG-CALL генерируется установление соответствующего окружения для текущей функции (SET-ENV), создание кадра активации (ALLOC), генерация вычисления и добавления в окружение аргументов функции, вызов самой функции (REG-CALL) и в конце восстановление окружения (RESTORE-ENV).

Фаза 3 - Ассемблер.
-------------------

Последним шагом компиляции является генерация байт-кода из ассемблер-кода. Ассемблирование происходит в 2 прохода.

При первом проходе мнемоники опкодов заменяются соответствующими байтами опкодов, при этом если встречается метка, то она не добавляется в результирующий байт-код, но запоминается в хеш-таблицу c адресом следующей инструкции, и если встречается инструкция перехода, то в отдельный список добавляется текущий адрес с меткой, которую использует данная инструкция.

Второй проход идёт по списку адресов с метками и в байт-коде заменяется соответствующие метки на адреса меток из хеш-таблицы.

Виртуальная машина
------------------------------

Точка входа виртуальной машины - функция vm-run:

::

  (vm-run program)
    program - байт-код (массив инструкций).

В байт-коде каждый байт - опкод или операнд инструкции.

Функция последовательно выполняет инструкции и возвращает значение регистра ACC в результате выполнения байт-кода.

Архитектура виртуальной машины
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Машина включает в себя память программы (где хранится байт код программы), память констант, память глобальных переменных, стек, список кадров активации и регистры.

В памяти программы хранятся инструкции программы в виде объектов NUMBER. Каждая команда состоит из кода операции и возможных параметров.

В памяти констант и глобальных переменных могут храниться объекты любых типов.

Стек может хранить объекты любых типов.

Кадры активации хранят набор локальных аргументов и ссылку на предыдущий кадр и номер глубины вызовов.

Регистры машины:

:PC: хранит адрес текущей выполняемой инструкции из памяти программы.
:ACC: хранит результат последней операции. Может быть любым объектом.
:FRAME: текущий кадр активации.

Список инструкций:
	   
:Код  Имя:            Описание
:0    CONST num:      поместить константу с номером num в регистр ACC.
:1    JMP ofs:        безусловный переход на смещение ofs относительно PC.
:2    JNT ofs:        если ACC != T, то относительный переход на смещение ofs.
:3    ALLOC n:        создать новый кадр активации с числом аргументов n.
                      извлечь из стека аргументы начиная с позиции 1
		      (0-й элемент остается в стеке)
:4    GLOBAL-REF i:   устанавливает регистру ACC значение глобальной переменной с
                      индексом i.
:5    GLOBAL-SET i:   устанавливает глобальной переменной с индексом i значение
                      регистра ACC.
:6    LOCAL-REF i:    загружает в ACC значение i локальной переменной
                      (текущего кадра активации).
:7    LOCAL-SET i:    присваивает локальной переменной i (текущего кадра активации)
                      значение регистра ACC.
:8    DEEP-REF i j:   загружает в ACC значение локальной переменной с индексом j
                      в кадре i (начиная от текущего).
:9    DEEP-SET i j:   присваивает локальной переменной j в кадре i значение
                      регистра ACC.
:10   PUSH:           добавляет значение регистра ACC в стэк.
:11   PACK n:         собирает последние n элементов из стека в список и добавляет
                      его в стек.
:12   REG-CALL ofs:   добавляет адрес следующей инструкции в стэк и производит
                      переход по смещению ofs.
:13   RETURN:         производит переход на адрес из верхушки стэка, при этом
                      удаляет этот адрес из стэка.
:14   FIX-CLOSURE ofs:  в регистр ACC добавляется объект замыкание с текущим
                      кадром активации и смещением на код функции относительно текущего
		      адреса ofs.
:15   SAVE-FRAME:     сохраняет кадр активации в стеке
:16   SET-FRAME num:  устанавливает кадр активации с номером num
                      относительно начала глубины вызовов.
:17   RESTORE-FRAME:  восстанавливает кадр активации из стека.
:18   PRIM n:         вызывает примитив с номером n из таблицы примитивов с
                      фиксированным числом аргументов.
:19   NPRIM n:        вызывает примитив с номером n из таблицы примитивов с
                      переменным числом аргументов.
:20   HALT:           останов машины
