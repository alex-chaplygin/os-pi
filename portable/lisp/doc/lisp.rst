Описание языка Лисп
===================

Интерфейс
---------

После запуска интерпретатора появляется цикл REPL (read, eval, print loop):

* чтение выражения;
* вычисление значения выражения;
* печать результата вычислений;
* цикл продолжается сначала.

Условием остановки цикла является символ EOF (конец файла или потока ввода).

S-выражения
-----------

Выражением является или атом (последовательность букв и символов) или список из нуля или более выражений, которые разделены пустотами (пробелы или переводы строк) и заключены в круглые скобки.

Пример выражений:
::

   avr
   ()
   (a)
   (a b c)
   (a b (c) d)

Разновидностью атомов являются целые числа. Все остальные атомы называются символами.

Вычисление выражений
--------------------

Каждое правильное выражение имеет значение (возвращает значение).

Если выражение является числом, строкой, массивом, то оно возвращает само число.

Если выражение - список, то первый элемент списка - это оператор (функция), остальные - аргументы. При вычислении выражения сначала вычисляются аргументы, затем оператор (исключение составляют особые операторы, у которых другой порядок вычислений).

Типы объектов
-------------

Объекты могут быть числами - 10, 20, 0xff, символами - AB, списками(парами) - (1 2), строками - "123", массивами - #(1 1 1)

Специальные формы
-----------------

1. (quote x) (особый оператор) возвращает свой аргумент без вычисления. Сокращенная запись - 'x.
   ::

      > (quote a)
      A
      > 'a
      A
      > (quote (a b c))
      (A B C)

#. (cond (p1 e1) ... (pn en)) (особый оператор). Выражения p вычисляются до тех пор, пока не будет значение T (истина). Как только такое выражение найдено, то возвращается значение соответствующего выражения e как результат всего выражения cond.
   ::

      > (cond ((eq 'a 'b) 'first)
              ((atom 'a) 'second))
      SECOND

#. (if <условие> <выражение true> <выражение false>)
   ::

      > (if (= a 1) 2 3) ; если a = 1, то 2, иначе 3

#. (setq <переменная1> <выражение1> ... <переменная_n> <выражение_n>).
   Создает глобальные переменные и присваивает им значения выражений. Возвращает значение последнего выражения.
   ::

      > (setq a 1 b 2 c 3) ; несколько присваиваний
      3

#. (progn e1 e2 .. en). Вычисляет все выражения e1 .. en. Возвращает результат последнего выражения en.

#. (tagbody <список символов или выражений>). Вычисляет выражения последовательно. Символы являются метками, на которые возможен переход с помощью оператора go.
   ::

      (tagbody
         (go a) ; переход на метку a
         (+ 1 2)
	 a
	 (* 4 5))

#. (block <имя> <список выражений>). Выражения вычисляются последовательно. Возможен выход из блока (return-from <имя блока> <результат вычисления блока>).
   ::

      > (block b1 1 2 3 (return-from b1 10) 4 5 6)
      10
      > (block b1 1 2 3 4 5 6)
      6
      > (block b1
            1
            (block b2
	       (return-from b1 5))
	    2)
      5

 #. (labels (<список функций>) <список выражений>). Определяет локальные функции (могут быть рекурсивными), вычисляет выражения.
    ::

       > (labels
          ((f (x) (+ x x))
	   (g (x) (* x x x)))
	      (f (g 10)))
        2000
	> (defun fac(x)
	   (labels
	      ((f (x a)
	         (if (= x 1) a
		   (f (- x 1) (* x a)))))
	     (f x 1)))
	     
	   > (f 4 5)
	   > (f 3 20)
	   > (f 2 60)
	   > (f 1 120)
      
Примитивы
---------

1. (atom x) если аргумент атом, то возвращает атом T (истина), иначе возвращает атом NIL эквивалентный пустому списку (), что означает ложь.
   ::

      > (atom 'a)
      T
      > (atom 10)
      T
      > (atom '(a b c))
      NIL
      > (atom '())
      T
      > (atom (atom 'a))
      T                 # функция внутри функции
      > (atom '(atom 'a))
      NIL           # цитирование отменяет вычисление, поэтому аргумент - список

2. (eq x y) возвращает T, если x и y - один и тот же объект, иначе возвращает NIL.
   ::

      > (eq 'a 'a)
      T
      > (eq 'a 'b)
      NIL
      > (eq '() '())
      T

3. (equal x y) возвращает T, если x и y равны по содержимому, иначе возвращает NIL.
   ::
      > (equal '(1 2 3) '(1 2 3))
      T
      > (equal #(a b c) #(a b c d))
      NIL
      > (equal "123" "123")
      T
      
4. (car x) возвращает первый элемент списка (левый объект пары).
   ::

      > (car '(a b c))
      A

5. (cdr x) возвращает все кроме первого элемента списка (правый объект пары).
   ::

      > (cdr '(a b c))
      (B C)

6. (cons x y) создает точечную пару с объектами x и y.
   ::

      > (cons 'a '(b c))
      (A B C)
      > (cons 'a (cons 'b (cons 'c '())))
      (A B C)
      > (cons '(a b) '(c d))
      ((A B) C D)

#. (and <список условий>). Логическое И.
   ::
      > (and (> a 10) (< a 20))
      (if (> a 10)
          (if (< a 20) T
	  NIL)
	  NIL)
      (if (not (> a 10)) NIL
         (if (not (< a 20)) NIL T))

#. (or <список условий>). Логическое ИЛИ
   ::
      > (or (= a 10) (= a 20))
      (if (= a 10) T
         (if (= a 20) T NIL))

#. (funcall <функция> <список аргументов>). Применяет функцию к аргументам.
   ::
      > (funcall '+ 1 2 3 4 5 6)
      21
      > (funcall '(lambda (x y) (+ x y)) 1 2)
      3
      > (funcall a 10 20)

#. (eval <выражение>). Вычисление выражения.
   ::

      > (eval '(+ 1 2))
      3

Комментарии
-----------

Комментарии идут после ; до конца строки:
::

   (defvar *global*) ; глобальная переменная
      
Лямбда выражения
----------------

Лямбда выражение - это анонимная (без имени) функция (lambda (p1 ... pn) e1 e2 .. en), где
p1 ... pn - это параметры функции, e1, e2, ..., en - выражения.

Вызов функции - это следующее выражение:
::

   ((lambda (p1 ... pn) e) a1 ... an)

Сначала вычисляются все аргументы a1 ... an. Затем каждому параметру p1 ... pn ставится в соответствие вычисленное значение аргументов a1 ... an. После этого вычисляется выражение e, содержащее параметры, вместо которых будут подставлены их значения.
::

   > ((lambda (x) (cons x '(b))) 'a)
   (A B)
   > ((lambda (x y) (cons x (cdr y)))
     'z
     '(a b c))
   (Z B C)

Определение функций
-------------------

Новую функцию можно создать с помощью оператора defun:
::

    > (defun null (x)
         (eq x NIL))
    NULL  # имя новой функции
    > (null 'a)
    NIL
    > (null '())
    T

Функция может иметь строку документации:
::

   (defun null (x)
   "проверяет аргумент на пустое значение"
         (eq x NIL))

Функции для работы со списками
------------------------------

Для изменения списков служат функции rplaca и rplacd. Эти функции изменяют элементы car и cdr в паре. Первый аргумент должен быть парой. Второй - любой объект.
Возвращается измененная пара (объект не копируется):
::

   > (defvar list '(a b c))
   LIST
   > (rplaca list 1)
   (1 b c)
   > list
   (1 b c)
   > (rplacd list nil)
   (1)
   > list
   (1)

Глобальные переменные
---------------------

Глобальные переменные существуют все время работы. Они создаются с помощью функции defvar имя_переменной [значение] (особая форма). Значение может быть выражением:
::

   > (defvar a 10)
   A
   > A
   10

При отстутствии значения в переменную записывается значение NIL
::

   > (defvar a)
   A
   > A
   NIL

Установить значение переменной можно с помощью функции setq (особая форма). Если такой переменной не было то она создается.
::

   > (setq a 1)
   1
   > a
   1

Можно одной функцией установить значения нескольких переменных:
::

   (setq a 1 b 2 c 3)

Если переменная локальная (параметр функции), то setq ее модифицирует:
::

   > (defun test(x)
        (setq x 10)) ; модификация параметра

Арифметические операции
-----------------------
::

   > (+ 1 2 3 4)
   10
   > (- 10 1 2)
   7
   > (* 20 30 10)
   6000
   > (/ 10 2) ; только 2 параметра
   5

Сравнение по значению:
::

   > (equal 4 4)
   T
   > (equal 1 2)
   NIL
   > (equal '(1 2) '(a 2))
   NIL
   > (equal '(a b) ('a b))
   T
   > (equal '((1) (a b)) '((1) (a b)))
   T
   > (equal "abc" "abc")
   T
   > (equal #(1 1 'a) #(1 1 'a))
   T

Сравнения:
::

   > (> 8 2)
   T
   > (< 8 2)
   NIL

Побитовое И (1 или более параметров):
::

   > (& 0xA1 1)
   1
   > (& 1 1 1)
   1

Побитовое ИЛИ (1 или более параметров):
::

   > (bitor 0xf 0 0xf0)
   255

Сдвиг влево (только 2 параметра):
::

   > (<< 1 2)
   4

Сдвиг вправо (только 2 параметра):
::

   > (>> 0xF0 4)
   15
	
Строки
------

Строки задаются в двойных кавычках:
::

   > (defvar str "abc")
   STR
   > str
   "abc"

Функция объединения строк (1 или более параметров):
::

   > (concat "abc " "cde")
   "abc cde"
   > (concat "abc")
   "abc"

Функция преобразования строки в символ:
::

   > (intern "A")
   A

Функция преобразования символа в строку:
::

   > (symbol-name 'abc)
   "ABC"
      
Массивы
-------

Массивы в виде константы задаются как:
::

   > #(1 2 3 4)
   #(1 2 3 4)

Создание пустого массива заданной длины:
::

   (make-array <имя массива> <размер>)
   (defvar arr (make-array 100)) ; массив из 100 элементов

Присвоение значения элементу массива (значением может быть любой объект):
::

   (seta <объект массив> <индекс> <объект значение>)
   > (seta 'arr 0 10) ; arr[0] = 10
   10
   > (seta 'arr 10 '(a b c)) ; arr[10] = (A B C)
   (A B C)

Чтение элемента массива:
::

   (aref <массив> <индекс>)
   > (aref 'arr 0)
   10

Индекс массива начинается с 0 и не может превышать размер.

Макросы
-------

Макрос задает шаблон для генерации выражения.
::
   
   (defmacro test (var val)
       (list 'defvar var val))

При вызове макроса сначала происходит вычисление тела макроса (развертывание макроса):
::

   (test abc 100) -> (defvar abc 100)

Затем получившееся выражение вычисляется:
::

   (defvar abc 100)
   ABC

Обратная кавычка (работает не обязательно в макросах) вычисляется как обычная кавычка (цитирование работает со всеми типами объектов):
::

   > `(a b c)
   (A B C)

Но она также позволяет указывать какие части цитирования должны быть вычислены. Эти части указываются с помощью запятой:
::

   > (defvar a 10)
   A
   > `(a b c ,a)
   (A B C 10)

Запятая может стоять перед выражением, которое вычистяется
::

   > (defvar a 10)
   A
   > `(a b c ,(+ 1 a))
   (A B C 11)

Запятая-at служит для того, чтобы подставить список (результат вычисления выражения внутри запятой-at должен быть списком):
::

   > (defvar a '(1 2 3))
   A
   > `(,a ,@a)
   ((1 2 3) 1 2 3)

Можно посмотреть результат макроподстановки с помощью функции macroexpand:
::

   > (macroexpand '(if (= 1 1) 2 3))
   (COND ((= 1 1) 2) (T 3))
