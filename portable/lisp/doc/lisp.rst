Описание языка Лисп
===================

Интерфейс
---------

После запуска интерпретатора появляется цикл REPL (read, eval, print loop):

* чтение выражения;
* вычисление значения выражения;
* печать результата вычислений;
* цикл продолжается сначала.

Условием остановки цикла является символ EOF (конец файла или потока ввода).

S-выражения
-----------

Выражением является или атом (последовательность букв и символов) или список из нуля или более выражений, которые разделены пустотами (пробелы или переводы строк) и заключены в круглые скобки.

Пример выражений:
::

   avr
   ()
   (a)
   (a b c)
   (a b (c) d)

Разновидностью атомов являются целые числа. Все остальные атомы называются символами.

Комментарии
-----------

Комментарии идут после ; до конца строки:
::

   (defvar *global*) ; глобальная переменная

Вычисление выражений
--------------------

Каждое правильное выражение имеет значение (возвращает значение).

Если выражение является числом, строкой, массивом, то оно возвращает само число.

Если выражение - список, то первый элемент списка - это оператор (функция), остальные - аргументы. При вычислении выражения сначала вычисляются аргументы, затем оператор (исключение составляют особые операторы, у которых другой порядок вычислений).

Типы объектов
-------------

Объекты могут быть числами - 10, 20, 0xff, 0.345, символами - AB, списками - (1 2), парами - (1 . 2), строками - "123", массивами - #(1 1 1), одиночными символами (элементы строк) - #\A, функциями #'(lambda (x) x). Логический тип представлен как nil - ложь, все остальное - истина (при выводе истины используется символ t).

Специальные формы
-----------------

1. (quote x) (особый оператор) возвращает свой аргумент без вычисления. Сокращенная запись - 'x.
   ::

      > (quote a)
      A
      > 'a
      A
      > (quote (a b c))
      (A B C)

#. (if <условие> <выражение true> <выражение false>). Истинное выражение - не равное nil.
   ::

      > (if (= a 1) 2 3) ; если a = 1, то 2, иначе 3

#. (setq <переменная1> <выражение1> ... <переменная_n> <выражение_n>).
   Создает глобальные переменные и присваивает им значения выражений. Возвращает значение последнего выражения.
   ::

      > (setq a 1 b 2 c 3) ; несколько присваиваний
      3

#. (progn e1 e2 .. en). Вычисляет все выражения e1 .. en. Возвращает результат последнего выражения en.

#. (tagbody <список символов или выражений>). Вычисляет выражения последовательно. Символы являются метками, на которые возможен переход с помощью оператора go. Возвращает nil.
   ::

      (tagbody
         (go a) ; переход на метку a
         (+ 1 2)
	 a
	 (* 4 5))

#. (catch <имя> <список выражений>). Блок с возможностью нелокального выхода. Вычисляется имя (имя блока). Выражения вычисляются последовательно. Если встречается (throw <имя блока> <результат вычисления блока>), то вычисляется имя блока и происходит выход из ближайшего блока с этим именем. Если не было выхода, то возвращает результат последнего выражения. Все имена вычисляются динамически.
   ::

      > (catch 'b1 1 2 3 (throw 'b1 10) 4 5 6)
      10
      > (catch 'b1 1 2 3 4 5 6)
      6
      > (catch 'b1
            1
            (catch 'b2
	       (throw b1 5))
	    2)
      5

 #. (labels (<список функций>) <список выражений>). Определяет локальные функции (могут быть рекурсивными), вычисляет выражения.
    ::

       > (labels
          ((f (x) (+ x x))
	   (g (x) (* x x x)))
	      (f (g 10)))
        2000
	> (defun fac(x)
	   (labels
	      ((f (x a)
	         (if (= x 1) a
		   (f (- x 1) (* x a)))))
	     (f x 1)))
	     
	   > (f 4 5)
	   > (f 3 20)
	   > (f 2 60)
	   > (f 1 120)
      
Примитивы
---------

1. (atom x) если аргумент атом, то возвращает атом T (истина), иначе возвращает атом NIL эквивалентный пустому списку (), что означает ложь.
   ::

      > (atom 'a)
      T
      > (atom 10)
      T
      > (atom '(a b c))
      NIL
      > (atom '())
      T
      > (atom (atom 'a))
      T                 # функция внутри функции
      > (atom '(atom 'a))
      NIL           # цитирование отменяет вычисление, поэтому аргумент - список

2. (eq x y) возвращает T, если x и y - один и тот же объект, иначе возвращает NIL.
   ::

      > (eq 'a 'a)
      T
      > (eq 'a 'b)
      NIL
      > (eq '() '())
      T
      
#. (car x) возвращает первый элемент списка (левый объект пары).
   ::

      > (car '(a b c))
      A

#. (cdr x) возвращает все кроме первого элемента списка (правый объект пары).
   ::

      > (cdr '(a b c))
      (B C)

#. (cons x y) создает точечную пару с объектами x и y.
   ::

      > (cons 'a '(b c))
      (A B C)
      > (cons 'a (cons 'b (cons 'c '())))
      (A B C)
      > (cons '(a b) '(c d))
      ((A B) C D)

#. (list e1 e2 ... en) создает список с элементами e1, e2 ... en.
   ::

      > (list 'a 'b 10)
      (A B 10)
      
#. (and <список условий>). Логическое И.
   ::
      > (and (> a 10) (< a 20))
      (if (> a 10)
          (if (< a 20) T
	  NIL)
	  NIL)
      (if (not (> a 10)) NIL
         (if (not (< a 20)) NIL T))

#. (or <список условий>). Логическое ИЛИ
   ::
      > (or (= a 10) (= a 20))
      (if (= a 10) T
         (if (= a 20) T NIL))

#. (funcall <функция> <аргументы>). Вызывает функцию с аргументами. Первый аргумент - объект-замыкание, остальные - аргументы функции.
   ::
      > (funcall #'+ 1 2 3 4 5 6)
      21
      > (funcall #'(lambda (x y) (+ x y)) 1 2)
      3
      > (funcall #'a 10 20)

#. (apply <функция> <список аргументов>). Применяет функцию к аргументам. Первый аргумент - объект-замыкание, второй - список аргументов.
   ::
      > (apply #'+ '(1 2 3 4 5 6))
      21
      > (apply #'(lambda (x y) (+ x y)) '(1 2))
      3
      > (apply #'a '(10 20))
      
#. (eval <выражение>). Вычисление выражения.
   ::

      > (eval '(+ 1 2))
      3

#. (error msg). Останавливает вычисление, выводит сообщение об ошибке, возвращается в REPL цикл.
   ::

      > (error "No arguments")
      ERROR: No arguments

Примитивы для работы со списками
------------------------------

Для изменения списков служат функции rplaca и rplacd. Эти функции изменяют элементы car и cdr в паре. Первый аргумент должен быть парой. Второй - любой объект.
Возвращается измененная пара (объект не копируется):
::

   > (defvar list '(a b c))
   LIST
   > (rplaca list 1)
   (1 b c)
   > list
   (1 b c)
   > (rplacd list nil)
   (1)
   > list
   (1)

Арифметические примитивы
------------------------

#. (+ e1 e2 ... en) - сложение элементов e1, e2 .. en. Могут быть целые и вещественные числа.
   ::

      > (+ 1 2 3)
      6
      > (+ 4.5 7.9)
      12.40000

#. (- e1 e2 ... en) - вычитание элементов e1, e2 .. en. Могут быть целые и вещественные числа.
   ::

      > (- 10 2 3)
      5
      > (- 10.5 7.9)
      2.600000

#. (* e1 e2 ... en) - умножение элементов e1, e2 .. en. Могут быть целые и вещественные числа.
   ::

      > (* 1 2 3)
      6
      > (* 0.1 0.1)
      0.010000

#. (/ e1 e2) - деление e1 на e2. Могут быть целые и вещественные числа.
   ::

      > (/ 10 3)
      3
      > (/ 10.0 3)
      0.3333333

#. (% e1 e2) - остаток от деления e1 на e2. Только с целыми числами.
   ::

      > (% 10 3)
      1

#. (> e1 e2) - сравнение выражений e1 и e2 на больше. Возвращает T или NIL
   ::

      > (> 10 3)
      T
      > (> 1 2)
      NIL

#. (< e1 e2) - сравнение выражений e1 и e2 на меньше. Возвращает T или NIL
   ::

      > (< 10 3)
      NIL
      > (< 1 2)
      T

#. (equal x y) возвращает T, если x и y равны по содержимому, иначе возвращает NIL.
   ::
      > (equal 4 4)
      T
      > (equal 1 2)
      NIL
      > (equal '(1 2) '(a 2))
      NIL
      > (equal '(a b) ('a b))
      T
      > (equal '((1) (a b)) '((1) (a b)))
      T
      > (equal "abc" "abc")
      T
      > (equal #(1 1 'a) #(1 1 'a))
      T

#. (& e1 e2 ... en) - побитовое И элементов e1, e2 .. en.
   ::
      > (& 0x12 1)
      0

#. (bitor e1 e2 ... en) - побитовое ИЛИ элементов e1, e2 .. en.
   ::
      > (bitor 0x10 1)
      17

#. (<< num b) - побитовый сдвиг влево числа num на b битов.
   ::
      > (<< 1 3)
      8

#. (>> num b) - побитовый сдвиг вправо числа num на b битов.
   ::
      > (>> 0x15 4)
      1
      
#. (sin num) - синус вещественного числа num.
   ::
      > (sin 0.0)
      0.000000

#. (cos num) - косинус вещественного числа num.
   ::
      > (cos 0.0)
      1.000000
      
Лямбда выражения
----------------

Лямбда выражение - это анонимная (без имени) функция (lambda (p1 ... pn) e1 e2 .. en), где
p1 ... pn - это параметры функции, e1, e2, ..., en - выражения.

Вызов функции - это следующее выражение:
::

   ((lambda (p1 ... pn) e) a1 ... an)

Сначала вычисляются все аргументы a1 ... an. Затем каждому параметру p1 ... pn ставится в соответствие вычисленное значение аргументов a1 ... an. После этого вычисляется выражение e, содержащее параметры, вместо которых будут подставлены их значения.
::

   > ((lambda (x) (cons x '(b))) 'a)
   (A B)
   > ((lambda (x y) (cons x (cdr y)))
     'z
     '(a b c))
   (Z B C)

Определение функций
-------------------

Новую функцию можно создать с помощью оператора defun:
::

    > (defun null (x)
         (eq x NIL))
    NULL  # имя новой функции
    > (null 'a)
    NIL
    > (null '())
    T

Функция может иметь строку документации:
::

   (defun null (x)
   "проверяет аргумент на пустое значение"
         (eq x NIL))

Глобальные переменные
---------------------

Глобальные переменные существуют все время работы. Они создаются с помощью функции defvar имя_переменной [значение] (особая форма). Значение может быть выражением:
::

   > (defvar a 10)
   A
   > A
   10

При отсутствии значения в переменную записывается значение NIL
::

   > (defvar a)
   A
   > A
   NIL

Установить значение переменной можно с помощью функции setq (особая форма). Если такой переменной не было то она создается.
::

   > (setq a 1)
   1
   > a
   1

Можно одной функцией установить значения нескольких переменных:
::

   (setq a 1 b 2 c 3)

Если переменная локальная (параметр функции), то setq ее модифицирует:
::

   > (defun test(x)
        (setq x 10)) ; модификация параметра

Глобальные переменные являются динамическими, то есть их значение используется всегда последнее, которое было связано.
   
Строки
------

Строки задаются в двойных кавычках:
::

   > (defvar str "abc")
   STR
   > str
   "abc"

Функция объединения строк (1 или более параметров):
::

   > (concat "abc " "cde")
   "abc cde"
   > (concat "abc")
   "abc"

Функция преобразования строки в символ:
::

   > (intern "A")
   A

Функция преобразования символа в строку:
::

   > (symbol-name 'abc)
   "ABC"

Длина строки:
::

   > (string-size "ABcdf")
   5

Получение символа из строки по индексу:
::

   > (char "abc" 0)
   #\a

Получение подстроки из строки, по начальному индексу и конечному индексу (не включается в результат):
::

   > (subseq "abcd123" 1 5)
   "bcd1"

Перевод целого числа в строку:
::

   > (inttostr 10)
   "10"

Создание строки заднной длины с заполнение символом:
::

   > (make-string 5 #\ )
   "     "

Замена символа в строке:
::

   > (defvar a (make-string 5 #\ ))
   "     "
   > (sets a 0 #\1)
   #\1
   > a
   "1    "

Прообразования символов:
::

   > (code-char 0x30) ; код в символ
   #\0
   > (char-code #\0) ; символ в код
   48
   

Массивы
-------

Массивы в виде константы задаются как:
::

   > #(1 2 3 4)
   #(1 2 3 4)

Создание пустого массива заданной длины:
::

   (make-array <имя массива> <размер>)
   (defvar arr (make-array 100)) ; массив из 100 элементов

Присвоение значения элементу массива (значением может быть любой объект):
::

   (seta <объект массив> <индекс> <объект значение>)
   > (seta 'arr 0 10) ; arr[0] = 10
   10
   > (seta 'arr 10 '(a b c)) ; arr[10] = (A B C)
   (A B C)

Чтение элемента массива:
::

   (aref <массив> <индекс>)
   > (aref 'arr 0)
   10

Размер массива:
::

   > (array-size #(1 2 3))
   3

Индекс массива начинается с 0 и не может превышать размер.

Предикаты типов
---------------

Проверка на символ:
::

   (symbolp 'asb)
   T
   (symbolp 1)
   NIL

Проверка на целое число:
::

   (integerp 'asb)
   NIL
   (integerp 1)
   T

Проверка на пару (список):
::

   (pairp 'asb)
   NIL
   (pairp '(1 2))
   T   
   (pairp '(1 . 2))
   T   

Проверка на строку:
::
   
   (stringp "astr")
   T
   (stringp 1)
   NIL
   
Проверка на массив:
::
   (arrayp 'asb)
   NIL
   (arrayp #(1 2 3))
   T 
   
Проверка на число с плавающей запятой:
::
   (floatp 'asb)
   NIL
   (floatp 1.0)
   T
   
Печать объектов
---------------

Любой объект можно напечатать с помощью функции print. Печатается объект и перевод строки:
::

   > (print 1)
   1
   > (print '(1 2 3))
   (1 2 3)

Одиночный символ печатается с помощью функции putchar:
::

   > (putchar #\#)
   #

Макросы
-------

Макрос задает шаблон для генерации выражения.
::
   
   (defmacro test (var val)
       (list 'defvar var val))

При вызове макроса сначала происходит вычисление тела макроса (развертывание макроса):
::

   (test abc 100) -> (defvar abc 100)

Затем получившееся выражение вычисляется:
::

   (defvar abc 100)
   ABC

Обратная кавычка (работает не обязательно в макросах) вычисляется как обычная кавычка (цитирование работает со всеми типами объектов):
::

   > `(a b c)
   (A B C)

Но она также позволяет указывать какие части цитирования должны быть вычислены. Эти части указываются с помощью запятой:
::

   > (defvar a 10)
   A
   > `(a b c ,a)
   (A B C 10)

Запятая может стоять перед выражением, которое вычисляется
::

   > (defvar a 10)
   A
   > `(a b c ,(+ 1 a))
   (A B C 11)

Запятая-at служит для того, чтобы подставить список (результат вычисления выражения внутри запятой-at должен быть списком):
::

   > (defvar a '(1 2 3))
   A
   > `(,a ,@a)
   ((1 2 3) 1 2 3)

Можно посмотреть результат макроподстановки с помощью функции macroexpand:
::

   > (macroexpand '(if (= 1 1) 2 3))
   (COND ((= 1 1) 2) (T 3))

Функции как объекты первого класса
----------------------------------

Мы можем передавать функции в качестве параметров других функций и возвращать функции.
Функции бывают:

* локальные;
* глобальные;
* встроенные;
* лямбда.

Пространство имен функций не совпадает с пространством имен переменных. Функция передается в качестве параметра как лямбда-выражение или символ.
Но при вызове функции из параметра мы должны указать, что имя символа (переменная) относится к пространству имен функций. Для вызова функций по параметру используется примитив funcall
Пример:
::

   > (funcall #'+ 1 2 3) ; вызов примитива
   6
   > (funcall #'(lambda (x y) (+ x y)) 2 3) ; вызов lambda
   5
   > (defun test (x) (+ x 1))
     (funcall #'test 4) ; вызов пользовательской функции по символу
     5
   > (defun compose (f g x)
       (funcall f (funcall g x)))
     (compose #'test #'test 6)
     8
  
Оператор #' является сокращением специальной формы function. #'test -- это (function test).

Использование свободной переменной в функции.
::
   
   > (let ((list '(a b c)))
       (map #'(lambda (x) (nth list x)) '(2 1 0))) ; замыкание с переменной list
   (C B A) ; несмотря на то, что переменная list есть в map

Специальная форма function создает объект-замыкание, в котором сохраняется текущее окружение. При применении функции-замыкания будет использоваться не текущее окружение, а окружение в котором было создано замыкание. Свободные локальные переменные являются лексическими, то есть сохраняют свое значение, которое было на момент замыкания. Глобальные переменные ведут себя динамическим образом - берется их значение в момент вызова функции.
   
Стандартная библиотека макросов lib.lsp
---------------------------------------

(cond (p1 e1) ... (pn en)) Выражения p вычисляются до тех пор, пока не будет значение истина (не nil). Как только такое выражение найдено, то возвращается значение соответствующего выражения e как результат всего выражения cond. В случае отсутствия такого условия возвращается nil
   ::

      > (cond ((eq 'a 'b) 'first)
              ((atom 'a) 'second))
      SECOND
