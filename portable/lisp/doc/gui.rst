Графический пользовательский интерфейс
======================================

Концептуальная модель
---------------------

Видимый элемент - это любой элемент программы,  который виден
на экране и все эти элементы являются объектами.
Поля, рамки
окон, полосы скроллинга,  полосы меню и диалоговые окна -  это  все
видимые элементы.
Видимые   элементы   могут   объединяться   для
формирования более сложных элементов таких,  как окна и  диалоговые
окна. Эти  наборы  видимых  элементов  называются  группами  и  они
работают вместе  так,  как  если   бы   это   был   один   элемент.
     Видимый элемент всегда  прямоугольный.
     

Создание видимых элементов
--------------------------
     
Видимые элементы интерфейса создаются через функции:

:element: базовый элемент
:window title: окно с заголовком
:textarea text: текст со строкой
:edit: поле ввода
:button text: кнопка с текстом


В этих функциях кроме обязательных параметров могут задаваться атрибуты объектов (общие для всех):

:id: Идентификатор объекта для поиска.
:width: Ширина объекта, если задана как parent, то ширина берется у родительского элемента.
:height: Высота объекта.
:back-color: Цвет фона (задаётся по умолчанию для разных типов объектов).
:active-color: Цвет фона для активного элемента (задаётся по умолчанию для разных типов объектов).
:children: Список дочерних объектов.
:alignment: Выравнивание объекта (виды выравнивания: left, center, right)
:display: Отображение объекта (none - невидимый, inline - в одной строке, block - перенесится на следующую строку).

Атрибуты присущие только элементам textarea и edit:

:text: Для поля ввода (edit) - введённый текст, для текстового элемента (textarea) - текст внутри компонента.
:color: Цвет текста (задаётся по умолчанию для textarea и edit).

Ширина и высота всех объектов вычисляется автоматически. Размеры элемента определяются размерами дочерних элементов. Для textarea и edit размеры определяются полем text. Для button ширина будет больше текста на заданное по умолчанию расстояние. Если ширина и высота были заданы, то они фиксируются (не увеличиваются при добавлении дочерних элементов и не уменьшаются при их удалении). 

Функции для работы с деревом объектов:

:add-child par ch: Добавление дочернего элемента ch к родительскому par.
:remove-child par ch: Удаление дочернего элемента ch у родительского par.
:get-element-by-id elem-id: Возвращает элемент, у которого id равен elem-id.

Пример.			    
::

   (setq w (element (id 1)))
   (setq b (button "Ok" (id 2)))
   (add-child w b)
   (remove-child (get-element-by-id 1) (get-element-by-id 2))

Обработчики событий
-------------------

Событие -  это  что-то,   на   что   программа   должна
отреагировать. События могут приходить от клавиатуры,  от мышки или
от других частей программы.

В текущий момент времени активен только один элемент. С помощью клавиши tab можно переключаться между активными элементами. При нажатии клавиши создается событие у активного элемента.

Виды событий (могут задаваться сразу как атрибуты объектов):

:keydown f: клавиша нажата
:keydown f: клавиша отпущена
:click f: Обработчик нажатия enter для кнопки.

Функция обработчик события должна принимать один аргумент, куда будет передаваться скан код клавиши. Для click - параметра нет.

Пользователь может задать обработчики событий программно:

:onkeydown: (onkeydown <элемент интерфейса> <функция обработчик события>)
            Задает функцию которая запускается по нажатию клавиши
:onkeyup: (onkeyup <элемент интерфейса> <функция обработчик события>)
          Задает функцию которая запускается по отжатию клавиши

Событие распространяется от дочернего элемента к родительскому.

Пример кода:
::
   
   (onkeydown (get-object-by-id 'main-window) '(lambda (key) (print key))) 

Экран представлен элементом, который хранится в глобальной переменной \*screen\*.   
Пример создания окна на экране:
::

   (add-child *screen*
       (window "Test" (id 'main-window) ; окно с идентификатором
	   (children
	       (textarea "login:") ; текстовое поле
	       (edit (width 10)) ; поле ввода (будет активно)
	       (button "OK"      ; после нажатия Tab кнопка станет активной
	            (display 'block) ; отображение кнопки на новой строке
		    (alignment 'center) ; выравнивание по центру
		    (click              ; при нажатии Enter на кнопку закроется окно
		       (lambda () (remove-child *screen* (get-object-by-id 'main-window))))))))
			         
Реализация
----------

Цикл событий
^^^^^^^^^^^^

Очередь событий глобальная структура данных. В нее поступают события по мере возникновения аппаратных прерываний. Например обработчик прерывания клавиатуры добавляет в очередь событий новую запись: нажата клавиша Escape или отпущена клавиша Space. Событие нажатия клавиатуры состоит из типа события  (keydown, keyup) и скан кода нажатой клавиши.

Цикл бесконечен и каждую свою иттерацию он проверяет очередь событий на пустоту. Если очередь содержит элементы, то цикл получает первый элемент очереди и по типу события(keyup, keydown) сопостовляет его с соответствующей глобальной структурой,после чего находит в данном списке нужный подсписок по ключу(выбраный в данный моменть элемент интерфейса пользователем), после чего сопостовляет его с соответсвующим списком пользовательских событий из глобальной структуры по скан коду клавиши,после чего запускает пользовательские события храннящиеся в этом списке.

Список окон хранится в глобальной переменной \*window-list\*. Окна это экземпляры класса window. Все остальные элементы являются дочерними для окон. Позиция для добавления нового окна \*current-window-pos\*, например (10 . 0).

Класс элемента
^^^^^^^^^^^^^^

Базовый класс для всех элементов - element. В нем хранятся свойства: 

:x: Координата x (относительно левого верхнего угла родительского элемента)
:y: Координата y (относительно левого верхнего угла родительского элемента)
:width: Ширина элемента
:height: Высота элемента
:text: Текст элемента
:color: Цвет текста элемента
:back-color: Цвет фона элемента
:active-color: Цвет фона, когда элемент активен
:parent: Родительский элемент
:children: Список дочерних элементов
:max-children-bottom: Максимальное расстояние от верхней границы родительского элемента до нижней границы дочерних элементов
:current-element-pos: Позиция для добавления нового дочернего элемента, например (22 . 5)
:padding: Массив с информацией об отступах с четырех сторон между рамкой окна и его дочерними элементами #(left right top bottom)

Методы:

:draw: Отрисовка элемента на экране
:add-child: Добавление дочернего элемента
:align: Выровнять элемент относительно родителя или экрана для окна
:set-defaults: Задание значения свойств элемента по умолчанию

Размещение окон
^^^^^^^^^^^^^^^

.. image:: img/windows.png

Очередное окно добавляется справа от последнего, если есть свободное место, иначе оно перемещается по координате x равной нулю, а по координате y на максимальное расстояние среди всех окон от верхней границы экрана до нижней границы окон (глобальная переменная \*max-windows-bottom\*).

Если окно выходит за пределы экрана по вертикали, то оно обрезается.
    
Размещение дочерних элементов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

При добавлении дочернего элемента, ширина родительского элемента должна увеличиться на ширину дочернего элемента. При добавлении блочного элемента увеличивается высота родительского элемента. При добавлении дочернего элемента обновляется максимальное расстояние от верхней границы родительского элемента до нижней границы дочерних элементов.При увеличении размеров родительского элемента происходит проверка на возможность размещения нового элемента. В случае выхода за пределы экрана по горизонтали, новый элемент добавляется по вертикали. Для всех элементов максимальной шириной является ширина экрана (минус правая и левая рамки окна) (константа +max-element-width+).

Дерево компонентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Дерево компонентов - это стек, на первом месте которого всегда ссылка на parent элемент, а на последующих стеки на первых местах которых ссылки его children элементы а на последующих уже стеки с их children и т.д. 
Функция get-parent у любого графического элемента возвращает ссылку на стек в котором хранится стек со ссылкой на этот элемент:
::
   (get-parent a)

Функция make-parent делает элемент a parent обьетом элемента b:
::
   (make-parent a b)

Функция children возвращет список get-children элементов элемента a:
::
   (get-children a)
Функция make-first переносит стек хранящий ссылку на элемент a на первую позицию среди children элементов его parent элемента:
::
   (make-first a)

Функция delete удаляет стек хранящий в себе ссылку на элемент a из дерева коспонентов:
::
   (delete a)
Основная задача дерева компонентов - формировать порядок отрисовки обьектов на экране и реализовывать смену активного окна путем изменения порядка children элементов в стеке.

Классы элементов
^^^^^^^^^^^^^^^^

Классы элементов наследуются от базового класса element:

* window;
* block;
* text;
* edit;
* button.

Для создания элементов применяются макросы window, block, text, button, edit. Сначала происходит создание объекта,  а затем установка конкретных свойств. Они возвращают экземпляры соответствующих классов. Простые свойства элемента устанавливаются через макрос setf, а children задаётся через отдельную функцию, которая сначала создаёт дочерние элементы, а затем добавляет их с помощью метода add-child.

При создании элемента происходит установка свойств по умолчанию, цвета родительского элемента копируются.

Отрисовка всех элементов происходит в функции screen после добавление окон в список. Для этого у каждого окна вызывается метод draw.

Отрисовка объектов
^^^^^^^^^^^^^^^^^^

Функция установки позиции курсора:
::

   (set-cursor x y)

Функция печати символа:
::

   (putchar "A")
   (putchar "\xF5")

Функции установки цвета:
::

   (set-color 0xf) ; установка цвета символа - белый
   (set-back-color 1);  установка цвета фона - синий

Функции для работы с курсором:
::

   (hide-cursor) ; спрятать курсор
   (show-cursor) ; показать курсор

Архитектура
-----------

Модуль gui/element.lsp - базовый класс element.

Модуль gui/window.lsp - класс окна.

Модуль gui/edit.lsp - класс поля ввода.

Модуль gui/block.lsp - класс группы элементов.

Модуль gui/text.lsp - класс текстового элемента.

Модуль gui/button.lsp - класс кнопки.

Модуль gui/interface.lsp - все макросы пользовательского интерфейса.

Модуль x86/sys.c - функции для отрисовки.

Свои идеи
^^^^^^^^^^^^^^^^^^
нужно добавить в стандартный список свойств element свойства:
:back-image: Изображение на заднем фоне элемента.
:image: Изображение на переднем плане элемента.
Добавить события:
:on-click: При нажатии на элемент.
:on-hover: При наведении курсора на элемент.
Например:
Функция on-click привязывает к элементу a событие удаления этого элемента из дерева компонентов при нажатии на него:
::
   (on-click a (lambda (a) (delete a)))
аналогичным образом работает функция on-hover.
Свойство parent в элементе хранит ссылку на соответствующий ему стек в дереве компонентов из него модно соответственно получить children элементы этого элемента.
inner-text и title излишние свойства для основного класса element, лучше отделить их в отдельный children класс text и при желании наличия текста в заголовке окна либо на кнопке и т.д. вручную добавлять их туда, тогда можно будет отследить такие вещи как: положение этого текста и его задний фон либо тогда сделать эти свойства по умолчанию у этих атрибутов element
все изменения положения  любого обьекта класса элемент производим через функцию move она сначала меняет местоположение обьекта а затем рекурсивно запускает себя для всех children элементов а в тех в свою очередь для их children и т.д.

