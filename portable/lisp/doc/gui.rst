Графический пользовательский интерфейс
======================================

Концептуальная модель
---------------------

Функция screen задаёт пользовательский интерфейс. Её параметры - список объектов верхнего уровня. Такими объектами могут быть только окна.

Объекты интерфейса задаются через функции, которые создают эти объекты и задают параметры. Виды объектов:

* окно (window);
* блочный элемент (block);
* текст (text);
* поле ввода (edit);
* кнопка (button).

Атрибуты объектов:

:inner-text: Для поля ввода - введённый текст, для остальных объектов - текст внутри компонента.
:title: Заголовок окна.
:width: Ширина объекта, если задана как parent, то ширина берется у родительского элемента.
:height: Высота объекта.
:color: Цвет текста (задаётся по умолчанию для разных типов объектов).
:back-color: Цвет фона (задаётся по умолчанию для разных типов объектов).
:active-color: Цвет фона для активного элемента (задаётся по умолчанию для разных типов объектов).
:children: Список дочерних объектов.
:alignment: Выравнивание объекта (виды выравнивания: left, center, right).
:click: Обработчик нажатия enter для кнопки.

Ширина и высота всех объектов вычисляется автоматически. Размеры окна и блочного элемента определяются размерами дочерних элементов. Для остальных элементов размеры определяются полем text. Для кнопки ширина будет больше текста на заданное по умолчанию расстояние. Если ширина и высота были заданы, то они фиксируются (не увеличиваются при добавлении дочерних элементов и не уменьшаются при их удалении). 

Элементы размещаются по горизонтали, только блочные - по вертикали.

В текущий момент времени активен только один элемент.

Пример:
::

   (screen
       (window "Test" (id 'main-window)
	   (children
	       (text "login:")
	       (edit (width 10))
	       (block (width 'parent)
                   (children
	               (button "OK"
		           (alignment 'center)
		           (click
		               (close (get-object-by-id 'main-window)))))))))
			      

Обработчики событий
-------------------

Пользователь может задать обработчики событий:

:onkeydown: (onkeydown <элемент интерфейса> <функция обработчик события>)
            Задает функцию которая запускается по нажатию клавиши
:onkeyup: (onkeyup <элемент интерфейса> <функция обработчик события>)
          Задает функцию которая запускается по отжатию клавиши

Функция обработчик события должна принимать один аргумент, куда будет передаваться код клавиши.

Событие распространяется от дочернего элемента к родительскому.

Пример кода:
::
   
   (onkeydown (get-object-by-id 'main-window) '(lambda (key) (print key))) 

   
Реализация
----------

Цикл событий
------------

Очередь событий глобальная структура данных. В нее поступают события по мере возникновения аппаратных прерываний. Например обработчик прерывания клавиатуры добавляет в очередь событий новую запись: нажата клавиша Escape или отпущена клавиша Space. Событие нажатия клавиатуры состоит из типа события  (keydown, keyup) и скан кода нажатой клавиши.

Цикл бесконечен и каждую свою иттерацию он проверяет очередь событий на пустоту. Если очередь содержит элементы, то цикл получает первый элемент очереди и по типу события(keyup, keydown) сопостовляет его с соответствующей глобальной структурой,после чего находит в данном списке нужный подсписок по ключу(выбраный в данный моменть элемент интерфейса пользователем), после чего сопостовляет его с соответсвующим списком пользовательских событий из глобальной структуры по скан коду клавиши,после чего запускает пользовательские события храннящиеся в этом списке.


Список окон хранится в глобальной переменной \*window-list\*. Окна это экземпляры класса window. Все остальные элементы являются дочерними для окон. Позиция для добавления нового окна \*current-window-pos\*, например (10 . 0).

Класс элемента
^^^^^^^^^^^^^^

Базовый класс для всех элементов - element. В нем хранятся свойства: 

:x: Координата x (относительно левого верхнего угла родительского элемента)
:y: Координата y (относительно левого верхнего угла родительского элемента)
:width: Ширина элемента
:height: Высота элемента
:text: Текст элемента
:color: Цвет текста элемента
:back-color: Цвет фона элемента
:active-color: Цвет фона, когда элемент активен
:parent: Родительский элемент
:children: Список дочерних элементов
:max-children-bottom: Максимальное расстояние от верхней границы родительского элемента до нижней границы дочерних элементов
:current-element-pos: Позиция для добавления нового дочернего элемента, например (22 . 5)
:padding: Массив с информацией об отступах с четырех сторон между рамкой окна и его дочерними элементами #(left right top bottom)

Методы:

:draw: Отрисовка элемента на экране
:add-child: Добавление дочернего элемента
:align: Выровнять элемент относительно родителя или экрана для окна
:set-defaults: Задание значения свойств элемента по умолчанию

Размещение окон
^^^^^^^^^^^^^^^

.. image:: img/windows.png

Очередное окно добавляется справа от последнего, если есть свободное место, иначе оно перемещается по координате x равной нулю, а по координате y на максимальное расстояние среди всех окон от верхней границы экрана до нижней границы окон (глобальная переменная \*max-windows-bottom\*).

Если окно выходит за пределы экрана по вертикали, то оно обрезается.
    
Размещение дочерних элементов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

При добавлении дочернего элемента, ширина родительского элемента должна увеличиться на ширину дочернего элемента. При добавлении блочного элемента увеличивается высота родительского элемента. При добавлении дочернего элемента обновляется максимальное расстояние от верхней границы родительского элемента до нижней границы дочерних элементов.При увеличении размеров родительского элемента происходит проверка на возможность размещения нового элемента. В случае выхода за пределы экрана по горизонтали, новый элемент добавляется по вертикали. Для всех элементов максимальной шириной является ширина экрана (минус правая и левая рамки окна) (константа +max-element-width+).

Дерево компонентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Дерево компонентов - это стек, на первом месте которого всегда ссылка на parent элемент, а на последующих стеки на первых местах которых ссылки его children элементы а на последующих уже стеки с их children и т.д. 
Функция parent у любого графического элемента возвращает ссылку на стек в котором хранится стек со ссылкой на этот элемент:
::
   (parent a)

Функция make-parent делает элемент a parent обьетом элемента b:
::
   (make-parent a b)

Функция children возвращет список children элементов элемента a:
::
   (children a)
Функция make-first переносит стек хранящий ссылку на элмент a на первую позицию среди children элементов его parent элемента:
::
   (make-first a)

Функция delete удаляет стек хранящий в себе ссылку на элемент a из дерева коспонентов:
::
   (delete a)
Основная задача дерева компонентов - формировать порядок отрисовки обьектов на экране и реализовывать смену активного окна путем изменения порядка children элементов в стеке.

Классы элементов
^^^^^^^^^^^^^^^^

Классы элементов наследуются от базового класса element:

* window;
* block;
* text;
* edit;
* button.

Для создания элементов применяются макросы window, block, text, button, edit. Сначала происходит создание объекта,  а затем установка конкретных свойств. Они возвращают экземпляры соответствующих классов. Простые свойства элемента устанавливаются через макрос setf, а children задаётся через отдельную функцию, которая сначала создаёт дочерние элементы, а затем добавляет их с помощью метода add-child.

При создании элемента происходит установка свойств по умолчанию, цвета родительского элемента копируются.

Отрисовка всех элементов происходит в функции screen после добавление окон в список. Для этого у каждого окна вызывается метод draw.

Отрисовка объектов
^^^^^^^^^^^^^^^^^^

Функция установки позиции курсора:
::

   (set-cursor x y)

Функция печати символа:
::

   (putchar "A")
   (putchar "\xF5")

Функции установки цвета:
::

   (set-color 0xf) ; установка цвета символа - белый
   (set-back-color 1);  установка цвета фона - синий

Функции для работы с курсором:
::

   (hide-cursor) ; спрятать курсор
   (show-cursor) ; показать курсор

Архитектура
-----------

Модуль gui/element.lsp - базовый класс element.

Модуль gui/window.lsp - класс окна.

Модуль gui/edit.lsp - класс поля ввода.

Модуль gui/block.lsp - класс группы элементов.

Модуль gui/text.lsp - класс текстового элемента.

Модуль gui/button.lsp - класс кнопки.

Модуль gui/interface.lsp - все макросы пользовательского интерфейса.

Модуль x86/sys.c - функции для отрисовки.

Свои идеи
^^^^^^^^^^^^^^^^^^
нужно добавить в стандартный список свойств element свойства:
:back-image: Изображение на заднем фоне элемента.
:image: Изображение на переднем плане элемента.
Добавить события:
:on-click: При нажатии на элемент.
:on-hover: При наведении курсора на элемент.
Например:
Функция on-click привязывает к элементу a событие удаления этого элемента из дерева компонентов при нажатии на него:
::
   (on-click a (lambda (a) (delete a)))
аналогичным образом работает функция on-hover.
Свойство parent в элементе хранит ссылку на соответствующий ему стек в дереве компонентов из него модно соответственно получить children элементы этого элемента.
inner-text и title излишние свойства для основного класса element, лучше отделить их в отдельный children класс text и при желании наличия текста в заголовке окна либо на кнопке и т.д. вручную добавлять их туда, тогда можно будет отследить такие вещи как: положение этого текста и его задний фон либо тогда сделать эти свойства по умолчанию у этих атрибутов element
все изменения положения  любого обьекта класса элемент производим через функцию move она сначала меняет местоположение обьекта а затем рекурсивно запускает себя для всех children элементов а в тех в свою очередь для их children и т.д.

