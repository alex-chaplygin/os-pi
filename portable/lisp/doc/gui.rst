Графический пользовательский интерфейс
======================================

Концептуальная модель
---------------------

Графический интерфейс пользователя это композиция набора повторяющихся элементов (окна, кнопки, поля ввода и т.д.).

Видимый элемент - это любой элемент программы,  который виден
на экране и все эти элементы являются объектами.
Поля, рамки
окон, полосы скроллинга,  полосы меню и диалоговые окна -  это  все
видимые элементы. Видимый элемент всегда  прямоугольный.

Видимые элементы можно структурировать в виде иерархии. Они   могут   объединяться   для
формирования более сложных элементов таких,  как окна и  диалоговые
окна. Существуют специальные элементы, которые могут включать другие элементы, в том числе другие группы элементов. Эти  группы  видимых  элементов  работают вместе  так,  как  если   бы   это   был   один   элемент. Если иерархия меняется, то меняется внешний вид. Перерисовка изменившихся частей интерфейса происходит автоматически.

Сам интерфейс определяется декларативно в виде разметки, которая отражает иерархию видимых элементов.

Базовые элементы
^^^^^^^^^^^^^^^^

:text: элемент с текстом
       (text <строка текста> <атрибут1> <атрибут2> ...)
:image: изображение
	(image <объект изображения> <атрибут1> <атрибут2> ...)


Групповые элементы
^^^^^^^^^^^^^^^^^^

:block: прямоугольная область, может иметь вложенные дочерние элементы, необходимо указывать координаты внутренних элементов
	(block <атрибут1> <атрибут2> ... <элемент1> <элемент2> ...)
:vert: внутренние элементы располагаются по вертикали, ширина и высота группы вычисляется автоматически
       	(vert <элемент1> <элемент2> ...)
:horiz: внутренние элементы располагаются по горизонтали, ширина и высота группы вычисляется автоматически
	(horiz <элемент1> <элемент2> ...)

Атрибуты видимых элементов
^^^^^^^^^^^^^^^^^^^^^^^^^^

:id: Идентификатор объекта для поиска.
:x: Координата x элемента, всегда относительно левого верхнего угла родителя
:y: Координата y элемента, всегда относительно левого верхнего угла родителя
:width: Ширина объекта.
:height: Высота объекта.
:back-color: Цвет фона (задаётся по умолчанию для разных типов объектов).
:active-color: Цвет фона для активного элемента (задаётся по умолчанию для разных типов объектов).
:keydown: Функция для обработки нажатия клавиши (параметр - код клавиши)
:keyup: Функция для обработки отпускания клавиши (параметр - код клавиши)


Функции для работы с деревом объектов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:add-child par ch: Добавление дочернего элемента ch к родительскому par.
:remove-child par ch: Удаление дочернего элемента ch у родительского par.
:get-element-by-id elem-id: Возвращает элемент, у которого id равен elem-id.

Пример.			    
::

   (setq w (block (id 1) (width 100) (height 100)))
   (setq b (text "Ok" (id 2) (x 10) (y 20)))
   (add-child w b)
   (remove-child (get-element-by-id 1) (get-element-by-id 2))

Обработчики событий
^^^^^^^^^^^^^^^^^^^

Событие -  это  что-то,   на   что   программа   должна
отреагировать. События могут приходить от клавиатуры,  от мышки или
от других частей программы.

В один момент времени активен только один элемент, по клавише tab происходит смена активного элемента на следующий в иерархии.

Пользователь может задать обработчики событий программно:

:onkeydown: (onkeydown <элемент интерфейса> <функция обработчик события>)
            Задает функцию которая запускается по нажатию клавиши
:onkeyup: (onkeyup <элемент интерфейса> <функция обработчик события>)
          Задает функцию которая запускается по отжатию клавиши

Событие распространяется от дочернего элемента к родительскому.

Пример кода:
::
   
   (onkeydown (get-object-by-id 'main-window) '#(lambda (key) (print key)))

Отображение интерфейса на экране
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Функция set-screen принимает на вход дерево видимых элементов и отображает его.
::

   (set-screen
       (vert ; вертикальная группа
	   (text "Test" (id 1)) ; текст
	   (horiz ; горизонтальная группа
	       (block (width 100) (height 100) (color 14) ; блок элементов
	            (text "Test2" (x 10) (y 20)) ; текстовое поле с абсолютными координатами
	       (block (width 10) (height 10) (backcolor 2) ; воображаемая кнопка
	            (keydown '#(lambda (k) ; функция обработчик нажатия клавиши
		                  (when (= k +enter+) ; если код Enter
				        ; меняем текст у первого элемента
				        (set-text (get-element-by-id 1) "TEST"))
					)))))))
			         
Реализация
----------

Цикл событий
^^^^^^^^^^^^

Очередь событий глобальная структура данных. В нее поступают события по мере возникновения аппаратных прерываний. Например обработчик прерывания клавиатуры добавляет в очередь событий новую запись: нажата клавиша Escape или отпущена клавиша Space. Событие нажатия клавиатуры состоит из типа события  (keydown, keyup) и скан кода нажатой клавиши.

Цикл бесконечен и каждую свою иттерацию он проверяет очередь событий на пустоту. Если очередь содержит элементы, то цикл получает первый элемент очереди и по типу события(keyup, keydown) сопостовляет его с соответствующей глобальной структурой,после чего находит в данном списке нужный подсписок по ключу(выбраный в данный моменть элемент интерфейса пользователем), после чего сопостовляет его с соответсвующим списком пользовательских событий из глобальной структуры по скан коду клавиши,после чего запускает пользовательские события храннящиеся в этом списке.

Список окон хранится в глобальной переменной \*window-list\*. Окна это экземпляры класса window. Все остальные элементы являются дочерними для окон. Позиция для добавления нового окна \*current-window-pos\*, например (10 . 0).

Класс элемента
^^^^^^^^^^^^^^

Базовый класс для всех элементов - element. В нем хранятся свойства: 

:x: Координата x (относительно левого верхнего угла родительского элемента)
:y: Координата y (относительно левого верхнего угла родительского элемента)
:width: Ширина элемента
:height: Высота элемента
:text: Текст элемента
:color: Цвет текста элемента
:back-color: Цвет фона элемента
:active-color: Цвет фона, когда элемент активен
:parent: Родительский элемент
:children: Список дочерних элементов
:max-children-bottom: Максимальное расстояние от верхней границы родительского элемента до нижней границы дочерних элементов
:current-element-pos: Позиция для добавления нового дочернего элемента, например (22 . 5)
:padding: Массив с информацией об отступах с четырех сторон между рамкой окна и его дочерними элементами #(left right top bottom)

Методы:

:draw: Отрисовка элемента на экране
:add-child: Добавление дочернего элемента
:align: Выровнять элемент относительно родителя или экрана для окна
:set-defaults: Задание значения свойств элемента по умолчанию

Размещение окон
^^^^^^^^^^^^^^^

.. image:: img/windows.png

Очередное окно добавляется справа от последнего, если есть свободное место, иначе оно перемещается по координате x равной нулю, а по координате y на максимальное расстояние среди всех окон от верхней границы экрана до нижней границы окон (глобальная переменная \*max-windows-bottom\*).

Если окно выходит за пределы экрана по вертикали, то оно обрезается.
    
Размещение дочерних элементов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

При добавлении дочернего элемента, ширина родительского элемента должна увеличиться на ширину дочернего элемента. При добавлении блочного элемента увеличивается высота родительского элемента. При добавлении дочернего элемента обновляется максимальное расстояние от верхней границы родительского элемента до нижней границы дочерних элементов.При увеличении размеров родительского элемента происходит проверка на возможность размещения нового элемента. В случае выхода за пределы экрана по горизонтали, новый элемент добавляется по вертикали. Для всех элементов максимальной шириной является ширина экрана (минус правая и левая рамки окна) (константа +max-element-width+).

Дерево компонентов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Дерево компонентов - это стек, на первом месте которого всегда ссылка на parent элемент, а на последующих стеки на первых местах которых ссылки его children элементы а на последующих уже стеки с их children и т.д. 
Функция get-parent у любого графического элемента возвращает ссылку на стек в котором хранится стек со ссылкой на этот элемент:
::
   (get-parent a)

Функция make-parent делает элемент a parent обьетом элемента b:
::
   (make-parent a b)

Функция children возвращет список get-children элементов элемента a:
::
   (get-children a)
Функция make-first переносит стек хранящий ссылку на элемент a на первую позицию среди children элементов его parent элемента:
::
   (make-first a)

Функция delete удаляет стек хранящий в себе ссылку на элемент a из дерева коспонентов:
::
   (delete a)
Основная задача дерева компонентов - формировать порядок отрисовки обьектов на экране и реализовывать смену активного окна путем изменения порядка children элементов в стеке.

Классы элементов
^^^^^^^^^^^^^^^^

Классы элементов наследуются от базового класса element:

* window;
* block;
* text;
* edit;
* button.

Для создания элементов применяются макросы window, block, text, button, edit. Сначала происходит создание объекта,  а затем установка конкретных свойств. Они возвращают экземпляры соответствующих классов. Простые свойства элемента устанавливаются через макрос setf, а children задаётся через отдельную функцию, которая сначала создаёт дочерние элементы, а затем добавляет их с помощью метода add-child.

При создании элемента происходит установка свойств по умолчанию, цвета родительского элемента копируются.

Отрисовка всех элементов происходит в функции screen после добавление окон в список. Для этого у каждого окна вызывается метод draw.

Отрисовка объектов
^^^^^^^^^^^^^^^^^^

Функция установки позиции курсора:
::

   (set-cursor x y)

Функция печати символа:
::

   (putchar "A")
   (putchar "\xF5")

Функции установки цвета:
::

   (set-color 0xf) ; установка цвета символа - белый
   (set-back-color 1);  установка цвета фона - синий

Функции для работы с курсором:
::

   (hide-cursor) ; спрятать курсор
   (show-cursor) ; показать курсор

Архитектура
-----------

Модуль gui/element.lsp - базовый класс element.

Модуль gui/window.lsp - класс окна.

Модуль gui/edit.lsp - класс поля ввода.

Модуль gui/block.lsp - класс группы элементов.

Модуль gui/text.lsp - класс текстового элемента.

Модуль gui/button.lsp - класс кнопки.

Модуль gui/interface.lsp - все макросы пользовательского интерфейса.

Модуль x86/sys.c - функции для отрисовки.

Свои идеи
^^^^^^^^^^^^^^^^^^
нужно добавить в стандартный список свойств element свойства:
:back-image: Изображение на заднем фоне элемента.
:image: Изображение на переднем плане элемента.
Добавить события:
:on-click: При нажатии на элемент.
:on-hover: При наведении курсора на элемент.
Например:
Функция on-click привязывает к элементу a событие удаления этого элемента из дерева компонентов при нажатии на него:
::
   (on-click a (lambda (a) (delete a)))
аналогичным образом работает функция on-hover.
Свойство parent в элементе хранит ссылку на соответствующий ему стек в дереве компонентов из него модно соответственно получить children элементы этого элемента.
inner-text и title излишние свойства для основного класса element, лучше отделить их в отдельный children класс text и при желании наличия текста в заголовке окна либо на кнопке и т.д. вручную добавлять их туда, тогда можно будет отследить такие вещи как: положение этого текста и его задний фон либо тогда сделать эти свойства по умолчанию у этих атрибутов element
все изменения положения  любого обьекта класса элемент производим через функцию move она сначала меняет местоположение обьекта а затем рекурсивно запускает себя для всех children элементов а в тех в свою очередь для их children и т.д.

