Реализация интерпретатора
=========================

Лексический анализатор (lexer.c)
--------------------------------

Лексический анализатор пропускает пустоты (пробелы, переводы строк) и выполняет распознавание лексем.

Правила распознавания через регулярные выражения:
::

   ; пропуск пустот
   Пустоты ::= [ \n\r\t]* 

   ; Числа T_NUMBER
   t_number ::= decimal | hex
   decimal ::= [0-9]+
   hex ::= 0x[0-9a-fA-F]+

   ; Символы T_SYMBOL
   t_symbol ::= start_sym sym*
   start_sym ::= letter | symbol
   sym ::= letter | digit | symbol
   letter ::= [a-zA-Z]
   digit ::= [0-9]
   symbol ::= [+-*/=_&|<>%]

   ;Одиночный символ T_CHAR
   t_char ::= #\<ascii_sym>
   t_function ::= #'

   ;Строка T_STRING
   t_string ::= "str_sym\*"
   str_sym ::= <ascii_sym> | \n | \x<число>


Символ начинается с буквы или разрешенного символа, может в себе содержать буквы, цифры, символы.

Синтаксический анализатор (parser.c)
------------------------------------

Синтаксический анализатор преобразовывает информацию из лексем и создает объекты соответствующего типа.

Представление объектов (objects.c)
----------------------------------

Каждый объект имеет тип и данные (в зависимости от типа).

Типы объектов:

* символ - переменная, идентификатор;
* малое целое число;
* большое целое число;
* число с плавающей точкой;
* одиночный символ (char) - элемент строки;
* пара (для представления списков);
* строка;
* массив объектов;
* функция;
* продолжение.

Объект представляет собой указатель, упакованный в целое число (4 или 8 байт), к которому добавлен код типа объекта в младших битах (число бит - TYPE_BITS). В бите MARK_BIT хранится флаг пометки сборки мусора. В указателе на объект все младшие биты числом TYPE_BITS+1 равны 0. Сам указатель указывает на разные структуры данных в зависимости от типа.

Для малых целых чисел во всех битах, кроме младших, хранится значение. Таким же образом хранится код одиночного символа (char).


Объекты со структурами распределяются из различных фиксированных массивов по мере надобности.

Чтобы младшие биты в указателе на структуру были равны 0, необходимо, чтобы размер каждой структуры был кратен 2^MARK_BIT.

Для освобождения памяти используется список свободных объектов:

.. image:: img/objects.png

Переменная free_objects_list указывает на начало списка свободных объектов (изначально пустой). В структуре объекта поле next указывает на следующий свободный объект. При освобождении объекта, данный объект добавляется в начало списка свободных объектов.

При создании объекта сначала берется объект по счетчику (от 0 до максимума объектов). Когда счетчик достигает максимального числа объектов, то объект берется из головы списка свободных объектов (при этом он должен быть удален из этого списка).

Для того, чтобы исключить повторное освобождение объектов и пар, в структуру добавлено поле, которое обозначает свободный ли этот объект или нет.
и
Пары выделяются и освобождаются аналогично.

Интерфейс для работы с объектами
--------------------------------
Создание объектов:

:new_number(int n): создание числа (создает большое число при необходимости)
:new_pair(object_t left, object_t right): создает пару из 2-х объектов
:NEW_STRING(char *s): создание строки

Тип объекта:
::

   TYPE(obj)
   
Извлечение объектов (все кроме чисел возвращают указатели на структуру):

:get_value(obj): извлечение числа
:GET_PAIR(obj): извлечение пары
:GET_STRING(obj): извлечение строкового объекта
:GET_SYMBOL(obj): извлечение символьного объекта
:GET_ARRAY(obj): извлечение массива
		 
Представление символов (symbols.c)
----------------------------------

Символы хранятся в своих структурах, где есть поле - строка (массив символов). Каждый символ должен храниться в единичном экземпляре. Это можно обеспечить с помощью хеш таблицы. Для строки символа вычисляется хеш-значение, которое используется как индекс в хеш-таблице.

Представление списков
---------------------

Списки выражений представлены парой объектов. Пара состоит из двух объектов (car и cdr). Объект car - это голова списка (первый элемент). Объект cdr - это пара, которая продолжает список (хвост списка).

Список (A B C) представляется следующим образом:

.. image:: img/list.jpg

Представление массивов и строк
------------------------------

Данные массивов (указатели на объекты) и строк (символы + 0) хранятся в специальной памяти регионов (массив байт фиксированной длины). Регионы организованы в двунаправленный список. Каждый регион может быть или свобоным или занятым, но не может быть последовательно идущих свободных регионов (они объединяются при освобождении).

Изначально существует один свободный регион, из которого выделяются области памяти.

.. image:: img/regions.png

Реализация примитивов
---------------------

Каждый примитив должен быть зарегистрирован как символ (имя функции), который имеет ссылку на функцию реализации примитива. Для этого в структуре символа есть поле func.

Реализация функций
------------------

Лямбда функции - это объект (lambda (p1 ... pn) выражение). При выполнении (применении к аргументам) функции необходимо создать окружение. Окружение - это ассоциативный список, где параметрам соответствуют вычисленные значения аргументов:
::
   
   (p1 . z1) (p2 . z2) ... (pn . zn)

Окружение хранит значения локальных связанных переменных, само окружение хранится в общей памяти. Глобальная
переменная current_env в начале вычислений пустая и по мере вызовов функций новые связки добавляются в начало
окружения,как кадры стека, и значения переменных ищутся сначала в локальном окружении, а затем в глобальном. Текущее
окружение помечается при сборке мусора и всегда остается в памяти.

Используя это окружение, можно выполнять подстановку, вместо параметра подставляется его значение.

Вновь созданные функции представляются как лямбда функции и хранятся как значения символа (имени функции).

Функция eval:
::

   object_t eval(object_t obj, object_t env)
   obj - объект, который вычисляем
   env - текущее окружение (в начале NULL)

В функции eval нам нужно вычислять выражения типа
::
   
   ((labmda (x) x) 1)
то есть на первом месте стоит лямбда.

Cсоответственно в eval мы должны проверять первый элемент списка, что это корректная lambda функция,это функция:
::

   int is_lambda(object_t *obj)
   
остается только:
::
   
   eval_func(object_t lambda, object_t args)
   
мы ее вызываем, передаем lambda объект и вычисленные аргументы (уже есть функция вычисляющая аргументы).
эта функция должна строить окружение, дополнительная функция:
::

   object_t make_env(object_t args, object_t values)
   
   args - список аргументов (x y)
   values - список значений (1 2)
   
   возвращает окружение ((X . 1) (Y . 2))
   
Далее нужно вызвать eval с созданным окружением и телом функции. Новое окружение должно быть добавлено впереди текущего (кадр стека). Например было окружение:
::

   ((X . 1))

Вызывается еще раз функция с параметром X = 2, получается окружение:
::

   ((X . 2) (X . 1))

В eval если встречается символ, то он ищется в окружении, если нет, то ошибка - неизвестный символ.
Если символ найден, то берется его значение из окружения.
Дополнительная функция:
::
   
   int find_in_env(object_t env, object_t sym, object_t *res)
   env - окружение где ищем,
   sym - символ, который ищем
   res - сюда записывается результат поиска
   возвращаемое значение - 1 - найдено, 0 - нет

Сборка мусора
-------------

В определенные моменты времени происходит сборка мусора: освобождение неиспользуемых объектов. Момент сборки мусора определяется когда число созданных пар с момента последней сборки мусора (allocated_pairs) превышает порог (GC_THRESHOLD). Затем это число обнуляется. Для сборки мусорка используем алгоритм пометки и очистки.

Фаза пометки
^^^^^^^^^^^^

Обходим все занятые символы в таблице символов. Выполняем пометку объектов на которые указывают символы (поле value). Пометка - это дополнительное поле mark в структуре объекта и пары. Если помечается объект-пара, то нужно также рекурсивно пометить левый и правый объект этой пары.

Фаза очистки
^^^^^^^^^^^^

Обходим все выделенные объекты и пары. Если есть пометка, то пометку снимаем. Если нет - то объект и/или пара освобождается.

Продолжения
^^^^^^^^^^^

Продолжение - это объект, который сохраняет в себе место в программе, в которое может быть потом возвращено
управление. Чтобы корректно восстановить управление, необходимо также сохранить окружение, которое было на момент
вычисления.
