;; ; Тесты обработчика регулярных выражений
(unit-tests 'regex)
;; (print "-----Regex handler tests-----")

;; (defun test-error (regex ref-error)
;;   (let ((chars (explode (concat "Expected: " ref-error ", got: "))))
;;     (dolist (chr chars)
;;       (putchar chr))
;;     (print (check-correctness regex))))

;; (print "Regex correctness checking tests")
;; (test-error "" "Empty regex")
;; (test-error "t^" "Unescaped ^ not in the beginning of regex")
;; (test-error "$$" "Unescaped $ not in the end of regex")
;; (test-error "ab*?f" "? Preceding token is not quantifiable")
;; (test-error "asd.*[a]* * *+" "+ Preceding token is not quantifiable")
;; (test-error "[ab]+. +%+ +* ?" "* Preceding token is not quantifiable")

;; (test-error "af[]" "Empty square brackets")
;; (test-error "a%[bc]" "Missing opening square bracket")
;; (test-error "^ab[xyz$" "Missing closing square bracket")
;; (test-error "^a[ab[dc]t]&" "Nested square brackets")

;; (print "Regex matching tests")


;; (print (assert (test-re "string" ".*") T))
;; (print (assert (test-re "bcdef" "^b..e.$") T))
;; (print (assert (test-re "abcd" "^bcd") NIL))

(unit-tests 'regex)

(deftest parse-sym-test ()
  "Тестирование символа"
  (let ((s1 (stream-from-str "a")))
    (print (assertcar (funcall (parse-sym) s1) '(sym #\a)))))

(deftest parse-element-test ()
  "Тестирование элемента"
  (let ((s1 (stream-from-str "a*"))
	(s2 (stream-from-str "b"))
	(s3 (stream-from-str ".*")))
    (print (assertcar (funcall (parse-element) s1) '(star (sym #\a))))
    (print (assertcar (funcall (parse-element) s2) '(sym #\b)))
    (print (assertcar (funcall (parse-element) s3) '(star (any))))))

(deftest parse-group-test ()
  "Тестирование группы"
  (let ((s1 (stream-from-str "(a*)"))
	(s2 (stream-from-str "(b)"))
	(s3 (stream-from-str "((b))")))
    (print (assertcar (funcall (parse-group) s1) '(star (sym #\a))))
    (print (assertcar (funcall (parse-group) s2) '(sym #\b)))
    (print (assertcar (funcall (parse-group) s2) '(sym #\b)))))

(deftest parse-expr-test ()
  "Тестирование выражения"
  (let ((s1 (stream-from-str "a*b*c"))
	(s2 (stream-from-str "abcd"))
	(s3 (stream-from-str "a"))
	(s4 (stream-from-str "a*(bcd)*"))
	(sor (stream-from-str "a|b|c"))
	(s5 (stream-from-str "a|bc(d*|e)")))
    (print (assertcar (funcall (parse-expression) s1) '(SEQ (STAR (SYM #\a))
							(STAR (SYM #\b))
							(SYM #\c))))
    (print (assertcar (funcall (parse-expression) s2) '(SEQ (SYM #\a)
							(SYM #\b)
							(SYM #\c)
							(SYM #\d))))
    (print (assertcar (funcall (parse-expression) s3) '(SYM #\a)))
    (print (assertcar (funcall (parse-expression) sor) '(OR (SYM #\a) (SYM #\b) (SYM #\c))))
    (print (assertcar (funcall (parse-expression) s4)
		      '(SEQ (STAR (SYM #\a)) (STAR (SEQ (SYM #\b) (SYM #\c) (SYM #\d))))))
    (print (assertcar (funcall (parse-expression) s5)
		      '(OR (SYM #\a) (SEQ (SYM #\b) (SYM #\c) (OR (STAR (SYM #\d)) (SYM #\e))))))))
						

;; (defun check(auto tape reference)
;;   (let ((result (foldl #'nfa-input auto tape)))
;;     (print (assert (nfa-end result) reference))))

;; (defun debug(auto tape &rest null)
;;   (print `(test ,auto))
;;   (print `(result = ,(nfa-end (foldl #'(lambda (a s)
;; 					 (print `(states ,(nfa-states a) sym ,s))
;; 					 (nfa-input a s))
;; 				     auto tape)))))

;; (deftest test-regex ()
;;   "NFA"
;;   (let* ((s1 (stream-from-str "a*"))
;; 	 (regex (car (funcall (parse-expression) s1)))
;; 	 (nfa (regex-to-nfa regex))
;; 	(auto (make-nfa `(,(car nfa)) (second nfa) `(,(third nfa)))) )
;;     (print regex)
;;     (print nfa)
;;     (debug auto (explode "aaa") T)
;;   ))
(defun test-auto (regex res)
  "Тест генерации автомата по выражению regex, res - эталонный автомат"
  (reset-state)
  (print (assert (regex-to-nfa (car (funcall (parse-expression) (stream-from-str regex)))) res)))

(deftest test-auto-sym ()
  "Генерация автомата: символ в регулярном выражении"
  (test-auto "a" '(1 ((1 #\a (2))) 2)))

(deftest test-auto-any ()
  "Генерация автомата: любой символ в регулярном выражении"
  (test-auto "." '(1 ((1 any (2))) 2)))

(deftest test-auto-star ()
  "Генерация автомата: звезда"
  (test-auto "b*" '(1 ((3 #\b (4)) (1 E (2)) (1 E (3)) (4 E (2)) (4 E (3))) 2)))

(deftest test-auto-seq ()
  "Генерация автомата: последовательность"
  (test-auto "abc" '(3 ((3 #\a (4)) (4 E (5)) (5 #\b (6)) (6 E (7)) (7 #\c (8))) 8)))

(deftest test-auto-or ()
  "Генерация автомата: альтернатива"
  (test-auto "a|b|c" '(1 ((1 E (3)) (3 #\a (4)) (4 E (2)) (1 E (5)) (5 #\b (6)) (6 E (2)) (1 E (7)) (7 #\c (8)) (8 E (2))) 2)))

(defun test-match (str regex)
  "Сопоставление строки str и строки регулярного выражения regex"
  (print str regex)
  (regex-match (compile-regex regex) str))

(deftest test-regex ()
  "Тестирование регулярных выражений"
  (print (assert (test-match "abc" "a.c") 't))
  (print (assert (test-match "offsabc4de" "abc4d") 't))
  (print (assert (test-match "offsabc4d" "abc4d") 't))
  (print (assert (test-match "abc4daaa" "abc4d") 't))
  (print (assert (test-match "abc4d" "abc4d") 't))
  (print (assert (test-match "1a---b 4d_" "b.4d.") 't))
  (print (assert (test-match "bcdef" "^b..e.$") 't))
  (print (assert (test-match "abcd" "^bcd") NIL))
  (print (assert (test-match "abcd" "abc$") NIL))
  (print (assert (test-match "ab" "^") ""))
  (print (assert (test-match "" "^$") ""))
  (print (assert (test-match "txt" "^$") NIL))
  (print (assert (test-match "a" ".") 't))
  (print (assert (test-match "" ".") NIL))
  (print (assert (test-match "aaaatd" "a*t") 't))
  (print (assert (test-match "aaaat" "a*t") 't))
  (print (assert (test-match "etd" "a*t") NIL))
  (print (assert (test-match "test" "t.*t") 't))
  (print (assert (test-match "test2" "t.*es.*t2") 't))
  (print (assert (test-match "string" ".*") 't))
  (print (assert (test-match "string" ".*") NIL))
  (print (assert (test-match "taaaabw" "a*b.$") "aaaabw"))
  (print (assert (test-match "test    string 123" "test * str.*2") "test    string 12"))
  (print (assert (test-match "ABCXYZ" "^A.*Z$") "ABCXYZ"))
  (print (assert (test-match "abcktrrrq" ".+ktr+.") 't))
  (print (assert (test-match "abcktrrrq" ".+ktr+.") 't))
  (print (assert (test-match "Hello" "Hel+o") 't))
  (print (assert (test-match "heo" "hel+o") NIL))
  (print (assert (test-match "Helo" "Hel?lo") "Helo"))
  (print (assert (test-match "привет" "при.*т") 't)) ; ограниченная поддержка юникода (рассматривает русские буквы как 2 байта символов)
  (print (assert (test-match "lisp" "lis[tpk]") "lisp"))
  (print (assert (test-match "lisb" "lis[tpk]") NIL))
  (print (assert (test-match "awwaawwt" "[aw]*") "awwaaww"))
  (print (assert (test-match "dksst__" "[aws]?[tds][tks]+") "dksst"))
  (print (assert (test-match "num 5350 test" "[0123456789]+") "5350"))
  (setq time_re "[012345]?[0123456789]:[012345][0123456789]")
  (print (assert (test-match "time: 27:15" time_re) "27:15"))
  (print (assert (test-match "time: 62:15" time_re) "2:15"))
  (print (assert (test-match "time: 1:27" time_re) "1:27"))
  (print (assert (test-match "time: 27:1" time_re) NIL))
  (setq url_re "https?://[w%.]*swsu%.ru")
  (print (assert (test-match "https://swsu.ru/faq" url_re) "https://swsu.ru"))
  (print (assert (test-match "https://swsu_ru/faq" url_re) NIL))
  (print (assert (test-match "https://do.swsu.ru/faq" url_re) NIL))
  (print (assert (test-match "http://www.swsu.ru/faq" url_re) "http://www.swsu.ru"))
  (setq simple_email_re "^[abcdef-]+@[abcdef-]+%.[abcdef]*")
  (print (assert (test-match "abc@af-af.de" simple_email_re) "abc@af-af.de"))
  (print (assert (test-match "abc@af-af,de" simple_email_re) NIL))
  (print (assert (test-match "aa@.de" simple_email_re) NIL))
  (print (assert (test-match "aa@af-af" simple_email_re) NIL))
  (print (assert (test-match "*****" "%*+") "*****"))
  (print (assert (test-match "...." "%.*") "...."))
  (print (assert (test-match ".abc" "%.*") "."))
  (print (assert (test-match "%%abc" "%%*") "%%"))
  (print (assert (test-match "abc$d" "abc%$") "abc$"))
  (print (assert (test-match "[][q[wx" "%[%]%[[qwe%[]+") "[][q[w"))
  (print (assert (test-match "a*t" "a%.?t") NIL))
  (print (assert (test-match "at" "a%.?t") "at"))
  (print (assert (test-match "test" "t.*t") "test")))

(run-tests)
