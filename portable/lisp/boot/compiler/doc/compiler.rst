Компилятор Lisp
==============================

Виртуальная машина
------------------------------

Точка входа виртуальной машины - функция vm-run:

::

  (vm-run program)
    program - байт-код (массив инструкций).

Каждая инструкция - пара, состаящая из опкода и операнда (для большинства инструкций).
Последовательно выполняет инструкции и возвращает значение регистра ACC в результате выполнения байт-кода.

Список регистров
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- PC - хранит адрес текущей выполняемой инструкции.
- ACC - хранит результат последней операции. Может быть любым объектом.
- GLOBALS-MEM - содержит данные для глобальных переменных; массив.
- STACK - стэк общего назначения; массив.

Список инструкций
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- LDA expr - поместить expr в регистр ACC.
- JMP addr - безусловный переход на addr относительно PC.
- JNT addr - если ACC != T, то относительный переход на addr.
- GLOBAL-SET i - устанавливает глобальной переменной из массива GLOBALS-MEM с индексом i значение регистра ACC.
- GLOBAL-GET i - устанавливает регистру ACC значение глобальной переменной из массива GLOBALS-MEM с индексом i.
- PUSH - добавляет значение регистра ACC в стэк.
- POP - загружает верхний элемент стека в регистр ACC, при этом удаляет этот элемент из стека.
- DROP n - удаляет n верхних элементов из стека.
- LOCAL-GET i - загружает в ACC значение i-го элемента стэка, начиная с верхушки (i = 0 - самый верхний элемент стэка, i = 1 - следующий и т.д.). Не изменяет стэк.
- LOCAL-SET i - присваивает элементу стека с индексом i, начиная с верхушки, значение регистра ACC.
- CALL addr - добавляет адрес следующей инструкции в стэк и производит относительный переход на адрес addr.
- RET - производит переход на адрес из верхушки стэка, при этом удаляет этот адрес из стэка.

Компилятор
------------------------------

Компиляция любого S-выражения начинается с функции compile:

::

   (compile expr)
     expr - любое S-выражение.

Создаёт байт-код, вычисляющий данное S-выражение.

В модуле compiler есть своё внутреннее состояние компиляции, состоящее из переменных:

- \*program\* - содержит промежуточный результат компиляции.
- \*globals\* - список глобальных переменных.
- \*globals-count\* - размер списка \*globals\*.
- \*comp-err\* - флаг, определяющий, произошла ли ошибка компиляции в результате последнего вызова функции compile.
- \*comp-err-msg\* - содержит строку последней ошибки компиляции, если ошибка была, иначе nil.
- \*funcs\* - список функций, содержащий названия аргументов.
- \*locals\* - окружение локальных переменных.

Функция сбрасывает своё внутреннее состояние и вызвает функцию inner-compile для рекурсивной компиляции различных конструкций:

::

   (inner-compile expr)
     expr - компилируемое S-выражение.


Компиляция констант
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является константой, т.е. атом и не символ (кроме T и NIL), тогда выражение компилируется как:

::

   (lda expr)


То есть константа загружается в регистр ACC.

Компиляция progn
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - символ PROGN, тогда для компиляции выражения PROGN вызывается функция compile-progn:

::

   (compile-progn lst)
     lst - список S-выражений, входящих в PROGN.

Компилирует байт-код, вычисляющий конструкцию PROGN. Последовательно компилирует каждое выражение в списке lst.

Пример:

::
   
   (progn 1 2 3)
     -> ((LDA 1)
         (LDA 2)
         (LDA 3))

Компиляция условий
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - символ IF, тогда для компиляци условия вызывается функция compile-if:

::

   (compile-if if-body)
     if-body - список, состоящий из условия,
     ветки по "Да" и ветки по "Нет".

Проверяет, что у if-выражения есть условие и 2 ветки, затем компилирует вычисление условия, условный переход на ветку по "Нет", ветку по "Да", безусловный переход на конец условия и ветку по "Нет".

Пример:

::
   
   (if t 1 2)
     -> ((LDA T)
         (JNT G1)
         (LDA 1)
         (JMP G2)
         G1
         (LDA 2)
         G2)

Компиляция глобальных переменных и SETQ.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является символом (кроме T и NIL), тогда компилятор проверяет, существует ли такой символ в глобальном контексте. Если нет, то возвращается ошибка компиляции, иначе выражение компилируется следующим образом:

::

   a -> ((global-get 0))

В данном примере значение переменной "a" хранится в массиве GLOBALS-MEM с индексом 0.

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - символ SETQ, тогда для компиляци SETQ-выражения вызывается функция compile-setq:

::
   
   (compile-setq setq-body)
     setq-body - пара из символа и устанавливаемого выражения.

Функция ищет устанавливаемый символ (поиск происходит сначала в локальном окружении, затем, если символ не найден, в глобальном). Если символ не найден ни в одном окружении, то в глобальное окружение добавляется данный символ. Далее компилируется устанавливаемое выражение, затем добавляется инструкция (global-set i) / (stack-set i), где i - индекс в GLOBALS-MEM / STACK.

Пример:

::

   (setq a 5)
     -> ((lda 5)
         (global-set 0))

Комплиятор подсчитывает количество глобальных переменных, и функция vm-run создаёт достаточно большой массив, способный вместить все глобальные переменные для данной программы.

Комплияция lambda-выражений.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - символ LAMBDA, тогда для компиляци лямбда-выражения вызывается функция compile-lambda:

::
   
   (compile-lambda lambda-body)
     lambda-body - список,
     CAR которго - список аргументов,
     а CDR - тело функции.

Функция проверяет на то, что (car lambda-body) - список, состоящий только из символов. Затем сохраняется текущее состояние локального окружения, и в список функций добавляется новая функция с меткой тела данной лямбда-функции и списком аргументов, чтобы при вызове функции проверить, совпадает ли количество передаваемых аргументов. Далее в локальное окружение добавляются в обратном порядке аргументы лямбда-функции, добавляется переход на метку после тела лямбда-функции, метка на тело, лямбда-функции, компилируется само тело (каждое выражение в (cdr lambda-body) по очереди), добавляется метка после тела. После этого восстанавливается локальное окружение.

Пример:

::

   (lambda (x) x)
     -> ((JMP G2)
         G1
         (LOCAL-GET 1)
         (RET)
         G2)

В примере показана компиляция лямбда-функции, как части конструкции вызова функции. Сама по себе лямбда-функция на данный момент не может быть объявлена и может быть лишь частью вызова функции.

Функция compile-lambda возвращает метку тела лямбда-функции, чтобы при компиляции вызова лямбда-функции знать, куда делать переход.

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - незарезервированный символ (не PROGN, IF, SETQ и т.д.) или лямбда-выражение, тогда для компиляции вызова функции вызывается функция compile-func-call:

::
   
   (compile-func-call label fparams)
     label - метка тела функции.
     fparams - список выражений параметров.

Функция проверяет, что количество переданных аргументов совпадает с ожидаемым, затем в обратном порядке компилируются аргументы: их вычисление и (push). Далее добавляется вызов функции: (call label), где label - метка вызываемой функции. В конце, если лямбда-функция принимает аргументы, то добавляется инструкция (drop args-len) для восстановления стека.

Пример:

::

   ((lambda (x) x) 10)
     -> ((JMP G2)
         G1
         (LOCAL-GET 1)
         (RET)
         G2
         (LDA 10)
         (PUSH)
         (CALL G1)
         (DROP 1))

Функция compile-func-call сначала по очереди вычисляет каждый параметр в обратном порядке, добавляя его в стек, затем добавляет инструкцию CALL, которая, кроме перехода на тело функции, добавляет в стек адрес следующей инструкции. После вызова инструкции CALL стек выглядит следующим образом (n - число аргументов):

   (param\ :sub:`n`\  param\ :sub:`n-1`\  ... param\ :sub:`2`\  param\ :sub:`1`\  ret_addr)

Таким образом, (LOCAL-GET 1) - обращение к первому параметру, (LOCAL-GET 2) - ко второму, и т.д.

Компиляция DEFUN
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - символ DEFUN, тогда для компиляци объявления функции вызывается функция compile-defun.

Пример:

::
   
   (defun f (x) x)
     -> ((JMP G2)
         G1
         (LOCAL-GET 1)
         (RET)
         G2)

Компиляция примитивов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в функции inner-compile параметр expr является списком, при этом первый элемент списка - символ, являющийся одним из примитивов, тогда для компиляци вызова примитива вызывается функция compile-prim.

Пример:

::

   (+ 1 2)
     -> ((LDA 2)
         (PUSH)
         (LDA 1)
         (PUSH)
         (PRIM2 3))

Инструкции PRIM1, PRIM2 и PRIM3 ожидают, что в стеке есть 1, 2 и 3 элементов соответственно и используют их как аргументы для вычисления примитива, загружают вычисленное значение в ACC и удаляют аргументы из стека. Аргументы передаются в стек в обратном порядке, так же, как и при вызове обычной функции.

Ассемблер
------------------------------

Последним шагом компиляции является ассемблирование: сначала мнемоники опкодов заменяются на их численное представление, затем вычисляются относительные адреса меток.

Пример:

::

   ((JMP G1)
    (LDA 1)
    G1
    (LDA 2))
   ->
   ((1 G1)
    (0 1)
    G1
    (0 2))
   ->
   #(1 4 0 1 0 2)

Ассемблер генерирует относительные адреса переходов в 2 прохода: сначала добавляет в список все встречающиеся метки и запоминает их абсолютные адреса, затем во всех инструкциях перехода заменяет метки на разницу адреса соответствующей метки и адреса текущей инструкции. Параллельно со вторым проходом генерирует массив байт-кода.
