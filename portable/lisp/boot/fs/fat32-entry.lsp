(defconst +fat32-entry-free+ 0)
(defconst +fat32-entry-deleted+ 0xE5)
(defconst +fat32-lfn-attribute+ 0xF)

(defun fat32-get-date-time (date-bytes time-bytes &rest creation-time-ms)
  "Получить список даты и времени из массивов байт date-bytes, time-bytes и creation-time-ms"
  (let ((date-num (arr-get-num date-bytes 0 2))
        (time-num (when (not (null time-bytes)) (arr-get-num time-bytes 0 2)))
        (time-ms-num (when (not (null creation-time-ms)) (arr-get-num (car creation-time-ms) 0 1)))
        (sec-plus 0)
        (date-time nil))
    (when (and (not (null time-ms-num)) (not (null time-num)) (>= time-ms-num 100))
      (setq sec-plus 1)
      (setq time-ms-num (- time-ms-num 100)))
    (setq date-time (list (+ (>> (& date-num 0xFE00) 9) 1980) (>> (& date-num 0x1E0) 5) (& date-num 0x1F)))
    (when (not (null time-num))
      (setq date-time (append date-time (list (>> (& time-num 0xF800) 11) (>> (& time-num 0x7E0) 5) (+ (* (& time-num 0x1F) 2) sec-plus)))))
    (when (not (null time-ms-num))
      (setq date-time (append date-time (list (* time-ms-num 10)))))
    date-time))

(defun fat32-generate-date-time (date-time)
  "Получить массив байт для даты и времени для записи в каталоге из списка даты и времени date-time"
  (let ((date (list (nth date-time 0) (nth date-time 1) (nth date-time 2)))
        (time (if (>= (list-length date-time) 6) (list (nth date-time 3) (nth date-time 4) (nth date-time 5)) nil))
        (time-ms (if (>= (list-length date-time) 7) (nth date-time 6) nil))
        (date-time-bytes (make-array 2)))
    (arr-set-num date-time-bytes 0 (+ (<< (+ (<< (- (nth date 0) 1980) 4) (nth date 1)) 5) (nth date 2)) 2)
    (when (not (null time))
      (when (and (= (% (nth time 2) 2) 1) (not (null time-ms)))
        (setq time-ms (+ time-ms 1000)))
      (setq date-time-bytes (array-cat #(0 0) date-time-bytes))
      (arr-set-num date-time-bytes 0 (+ (<< (+ (<< (nth time 0) 6) (nth time 1)) 5) (/ (nth time 2) 2)) 2))
    (when (not (null time-ms))
      (setq date-time-bytes (array-cat (list-to-array (list (/ time-ms 10))) date-time-bytes))) 
    date-time-bytes))

(defun fat32-get-attributes (attribute-byte)
  "Получить список атрибутов из записи в каталоге из байта attribute-byte"
  (let ((attributes nil)
        (all-attributes #(READ-ONLY HIDDEN SYSTEM VOLUME-ID DIRECTORY ARCHIVE nil nil)))
    (setq attribute-byte (arr-get-num attribute-byte 0 1))
    (for i 0 8
         (unless (or (= i 6) (= i 7))
           (unless (= 0 (& attribute-byte (expt 2 i)))
             (setq attributes (cons (aref all-attributes i) attributes)))))
    attributes))

(defun fat32-generate-attribute-byte (attributes)
  "Получить байт атрибутов для записи в каталоге из списка атрибутов attributes"
  (let ((attribute-byte 0)
        (all-attributes '(READ-ONLY HIDDEN SYSTEM VOLUME-ID DIRECTORY ARCHIVE)))
    (while (not (null attributes))
      (setq attribute-byte (+ attribute-byte (expt 2 (list-search all-attributes (car attributes)))))
      (setq attributes (cdr attributes)))
    attribute-byte))

;; Каждый символ 2 байта
(defun parse-lfn-entry ()
  "Парсер структуры записи длинного имени"
  (&&& lfn-entry->(parse-struct '((lfn-number . 1)
                                  (str-1 . 10)
                                  (attributes . 1) ;; 15(0x0F)
                                  (entry-type . 1) ;; 0
                                  (checksum . 1) ;; из dir-entry
                                  (str-2 . 12)
                                  (reserved . 2) ;; 0
                                  (str-3 . 4)))
       return (progn
		(let ((lfn-string "")
                      (str-ended nil))
                  (for i 0 5
                       (unless str-ended
                         (let ((code (arr-get-num (get-hash lfn-entry 'str-1) (* i 2) 2)))
                           (if (= code 0xFFFF)
                               (setq str-ended t)
                               (setq lfn-string (concat lfn-string (make-string 1 (code-char code))))))))
                  (for i 0 6
                       (unless str-ended
                         (let ((code (arr-get-num (get-hash lfn-entry 'str-2) (* i 2) 2)))
                           (if (= code 0xFFFF)
                               (setq str-ended t)
                               (setq lfn-string (concat lfn-string (make-string 1 (code-char code))))))))
                  (for i 0 2
                       (unless str-ended
                         (let ((code (arr-get-num (get-hash lfn-entry 'str-3) (* i 2) 2)))
                           (if (= code 0xFFFF)
                               (setq str-ended t)
                               (setq lfn-string (concat lfn-string (make-string 1 (code-char code))))))))
                  lfn-string))))

;; Каждый символ 1 байт
(defun parse-fat32-dir-entry ()
  "Парсер структур записи в каталоге"
  (&&& fat32-dir-entry->(parse-struct '((short-name . 11)
					(attributes . 1)
					(reserved . 1)
					(creation-time-ms . 1)
					(creation-time . 2) ;; seconds * 2
					(creation-date . 2)
					(access-date . 2)
					(first-block-1 . 2)
					(modification-time . 2)
					(modification-date . 2)
					(first-block-2 . 2)
					(size-bytes . 4))) ;; 0 для каталогов
       return (progn
		(let ((dir-entry (make-hash))
                      (name-first (car (split #\  (arr-get-str (get-hash fat32-dir-entry 'short-name) 0 8))))
                      (name-second (car (split #\  (arr-get-str (get-hash fat32-dir-entry 'short-name) 8 3)))))
                  (set-hash dir-entry 'name (if (equal name-second "")
						name-first
						(concat (concat name-first ".") name-second)))
                  (set-hash dir-entry 'size (arr-get-num (get-hash fat32-dir-entry 'size-bytes) 0 4))
                  (set-hash dir-entry 'first-block (arr-get-num (array-cat (get-hash fat32-dir-entry 'first-block-1) (get-hash fat32-dir-entry 'first-block-2)) 0 4))
                  (set-hash dir-entry 'creation-date-time (fat32-get-date-time (get-hash fat32-dir-entry 'creation-date) (get-hash fat32-dir-entry 'creation-time) (get-hash fat32-dir-entry 'creation-time-ms)))
                  (set-hash dir-entry 'modify-date-time (fat32-get-date-time (get-hash fat32-dir-entry 'modification-date) (get-hash fat32-dir-entry 'modification-time)))
                  (set-hash dir-entry 'access-date (fat32-get-date-time (get-hash fat32-dir-entry 'access-date) nil))
                  (set-hash dir-entry 'attributes (fat32-get-attributes (get-hash fat32-dir-entry 'attributes)))
                  (set-hash dir-entry 'parent-first-block nil)
                  (set-hash dir-entry 'short-name (get-hash dir-entry 'name))
                  (set-hash dir-entry 'dir (contains (get-hash dir-entry 'attributes) 'DIRECTORY))
                  dir-entry))))

(defun fat32-calc-lfn-count (name)
  "Посчитать количество записей длинного имени для имени name"
  (let ((name-size (string-size name))
        (lfn-count 0))
    (setq lfn-count (/ name-size 13))
    (setq name-size (% name-size 13))
    (when (!= name-size 0)
      (incf lfn-count))
    lfn-count))

(defun fat32-generate-checksum (short-name)
  "Посчитать контрольную сумму короткого имени для записи длинного имени"
  (setq short-name (split #\. short-name))
  (let ((left-length 8)
        (short-name-1 (car short-name))
        (short-name-2 (if (= (list-length short-name) 2) (cadr short-name) nil)))
    (when (> (string-size short-name-1) 8) (throw 'error "create-dir-entry: short name name-size in entry is more than 8 symbols"))
    (setq left-length (- left-length (string-size short-name-1)))
    (setq short-name-1 (concat short-name-1 (make-string left-length #\ )))
    (setq short-name short-name-1)
    (when (not (null short-name-2))
      (when (> (string-size short-name-2) 3) (throw 'error "create-dir-entry: short name extension-size in entry is more than 3 symbols"))
      (setq left-length (- 3 (string-size short-name-2)))
      (setq short-name-2 (concat short-name-2 (make-string left-length #\ ))))
    (if (not (null short-name-2))
        (setq short-name (concat short-name short-name-2))
        (setq short-name (concat short-name "   ")))
    (let ((checksum (char-code (char short-name 0))))
      (for i 1 11
           (setq checksum (+ (>> checksum 1) (char-code (char short-name i)))))
      checksum)))

(defun fat32-create-lfn-entry (name-part-str lfn-num checksum)
  "Создать одну запись длинного имени для строки name-part-str"
  (let ((byte-array (make-array 32)))
    (seta byte-array 0 (+ 0x40 lfn-num))
    (when (< (string-size name-part-str) 13)
      (setq name-part-str (concat name-part-str (make-string (- 13 (string-size name-part-str)) (code-char 0xFFFF)))))
    (for i 0 5
         (arr-set-num byte-array (+ 1 (* i 2)) (char-code (char name-part-str i)) 2))
    (seta byte-array 11 +fat32-lfn-attribute+)
    (seta byte-array 12 0)
    (seta byte-array 13 checksum)
    (for i 0 6
         (arr-set-num byte-array (+ 14 (* i 2)) (char-code (char name-part-str (+ i 5))) 2))
    (seta byte-array 26 0)
    (seta byte-array 27 0)
    (for i 0 2
         (arr-set-num byte-array (+ 28 (* i 2)) (char-code (char name-part-str (+ i 11))) 2))
    byte-array))

(defun fat32-create-lfn-entries (entry)
  "Создать записи длинного имени для записи в каталоге entry"
  (let ((checksum (fat32-generate-checksum (get-hash entry 'short-name)))
        (lfn-bytes #())
        (lfn-count (fat32-calc-lfn-count (get-hash entry 'name)))
        (entry-name (get-hash entry 'name)))
    (for i 0 lfn-count
         (setq lfn-bytes (array-cat (fat32-create-lfn-entry (subseq entry-name (* i 13) (if (<= 13 (- (string-size entry-name) (* i 13))) (+ 13 (* i 13)) (+ (- (string-size entry-name) (* i 13)) (* i 13)))) (+ i 1) checksum) lfn-bytes)))
    lfn-bytes))

(defun fat32-create-dir-entry (entry)
  "Создать массив байт записи в каталоге entry"
  (let ((byte-array (make-array 12))
        (short-name (split #\. (get-hash entry 'short-name))))
    (let ((left-length 8)
          (short-name-1 (car short-name))
          (short-name-2 (if (= (list-length short-name) 2) (cadr short-name) nil)))
      (when (> (string-size short-name-1) 8) (throw 'error "create-dir-entry: short name name-size in entry is more than 8 symbols"))
      (setq left-length (- left-length (string-size short-name-1)))
      (setq short-name-1 (concat short-name-1 (make-string left-length #\ )))
      (arr-set-str byte-array 0 short-name-1 8)
      (if (not (null short-name-2))
          (progn
            (when (> (string-size short-name-2) 3) (throw 'error "create-dir-entry: short name extension-size in entry is more than 3 symbols"))
            (setq left-length (- 3 (string-size short-name-2)))
            (setq short-name-2 (concat short-name-2 (make-string left-length #\ ))))
          (setq short-name-2 "   "))
      (arr-set-str byte-array 8 short-name-2 3)
      (seta byte-array 11 (fat32-generate-attribute-byte (get-hash entry 'attributes)))
      (let ((creation-date-time (fat32-generate-date-time (get-hash entry 'creation-date-time)))
            (modify-date-time (fat32-generate-date-time (get-hash entry 'modify-date-time)))
            (access-date (fat32-generate-date-time (get-hash entry 'access-date)))
            (blocks-arr (make-array 4))
            (size-arr (make-array 4)))
        (arr-set-num blocks-arr 0 (car (get-fat-chain (get-hash entry 'first-block))) 4)
        (arr-set-num size-arr 0 (get-hash entry 'size) 4)
        (setq byte-array (array-cat byte-array #(0)))
        (setq byte-array (array-cat byte-array creation-date-time))
        (setq byte-array (array-cat byte-array access-date))
        (setq byte-array (array-cat byte-array (array-seq blocks-arr 0 2)))
        (setq byte-array (array-cat byte-array modify-date-time))
        (setq byte-array (array-cat byte-array (array-seq blocks-arr 2 4)))
        (setq byte-array (array-cat byte-array size-arr))))
    byte-array))

(defun fat32-create-lfn-dir-entries (entry)
  "Создать массив байт записей длинного имени и записи в каталоге entry"
  (array-cat (fat32-create-lfn-entries entry) (fat32-create-dir-entry entry)))

(defun fat32-find-entry-pos (entry)
  "Найти позицию (смещение в списке блоков . смещение в блоке) для записи в каталоге entry в каталоге dir"
  (let ((blocks (get-fat-chain (get-hash entry 'parent-first-block)))
        (found nil)
        (offset 0)
        (block-stream nil)
        (lfn-name "")
        (block-copy nil))
    (setq block-copy blocks)
    (while (not (null blocks))
      (setq block-stream (stream-from-arr (block-read (car blocks)) nil))
      (while (not (null block-stream))
        (let ((next-byte (get-byte block-stream)))
          (unless (null next-byte)
            (setq offset (+ offset 32))
            (case (car next-byte)
              (+fat32-entry-deleted+ block-stream (cdr (get-array block-stream 32)))
              (+fat32-entry-free+ (setq blocks '(nil) block-stream nil))
              (otherwise
               (let ((entry-attributes (aref (car (get-array block-stream 12)) 11)))
                 (if (= entry-attributes +fat32-lfn-attribute+)
                     (progn
                       (let ((parse-res (funcall (parse-lfn-entry) block-stream)))
                         (setq lfn-name (concat (car parse-res) lfn-name))
                         (setq block-stream (cdr parse-res))))
                     (progn
                       (let ((parse-res (funcall (parse-fat32-dir-entry) block-stream)))
                         (set-hash (car parse-res) 'name lfn-name)
                         (setq lfn-name "")
                         (setq block-stream (cdr parse-res))
                         (when (equal (get-hash entry 'short-name) (get-hash (car parse-res) 'short-name))
                           (setq found (get-blocks-pos block-copy (- offset 32))
                                 blocks '(nil) block-stream nil)))))))))))
      (setq blocks (cdr blocks)))
    found))

;; Заглушка
(defun new-block (fat32fs first-block) nil)

(defun fat32-get-free-entry-pos (dir-first-block entries-count)
  "Найти позицию (смещение в списке блоков . смещение в блоке) в каталоге, где первый блок dir-first-block, где сможет поместиться количество записей entries-count. При необходимости выделяется новый блок"
  (let ((dir-blocks (get-fat-chain dir-first-block))
        (dir-blocks-len 0)
        (blocks-stream (make-instance 'File))
        (empty-count 0))
    (setq dir-blocks-len (* *block-size* (list-length dir-blocks)))
    (File-set-size blocks-stream dir-blocks-len)
    (File-set-blocks blocks-stream dir-blocks)
    (File-set-position blocks-stream '(0 . 0))
    (while (< empty-count entries-count)
      (when (> (+ (get-offset-from-pos (File-position blocks-stream)) 32) dir-blocks-len)
        (let ((file-object (make-hash)))
          (set-hash file-object 'first-block dir-first-block)
          (new-block *file-system* file-object))
        (setq dir-blocks (get-fat-chain dir-first-block))
        (File-set-blocks blocks-stream dir-blocks)
        (setq dir-blocks-len (+ dir-blocks-len *block-size*)))
      (let ((next-byte-arr (read-file blocks-stream 1)))
        (if (or
             (= (aref next-byte-arr 0) +fat32-entry-free+)
             (= (aref next-byte-arr 0) +fat32-entry-deleted+))
            (incf empty-count)
            (setq empty-count 0)))
      (seek-file blocks-stream 31 'CUR))
    (seek-file blocks-stream (* -32 entries-count) 'CUR)
    (File-position blocks-stream)))

(defun fat32-mark-for-delete (entry)
  "Пометить записей длинного имени и записи в каталоге entry на удаление"
  (let ((parent-blocks (get-fat-chain (get-hash entry 'parent-first-block)))
        (parent-block-len 0)
        (blocks-stream (make-instance 'File))
        (lfn-count 0)
        (entry-deleted-arr #(0)))
    (seta entry-deleted-arr 0 +fat32-entry-deleted+)
    (setq parent-block-len (* *block-size* (list-length parent-blocks)))
    (File-set-size blocks-stream parent-block-len)
    (File-set-blocks blocks-stream parent-blocks)
    (File-set-position blocks-stream '(0 . 0))
    (for i 0 (/ parent-block-len 32)
         (let ((next-byte-arr (read-file blocks-stream 1))
               (dir-entry nil))
           (when (= (aref next-byte-arr 0) +fat32-entry-free+)
             (throw 'error "fat32-mark-for-delete: entry not found"))
           (seek-file blocks-stream 10 'CUR)
           (if (= (aref (read-file blocks-stream 1) 0) +fat32-lfn-attribute+)
               (progn
                 (seek-file blocks-stream 20 'CUR)
                 (incf lfn-count))
               (progn
                 (seek-file blocks-stream -12 'CUR)
                 (setq dir-entry (car (funcall
                                       (parse-fat32-dir-entry)
                                       (stream-from-arr (read-file blocks-stream 32) nil))))
                 (when (equal (get-hash entry 'short-name) (get-hash dir-entry 'short-name))
                   (seek-file blocks-stream 1 'CUR)
                   (for i 0 (+ lfn-count 1)
                        (seek-file blocks-stream -33 'CUR)
                        (write-file blocks-stream entry-deleted-arr))
                   (setq i (/ parent-block-len 32)))
                 (setq lfn-count 0)))))))

(defun fat32-update-entry (entry changes)
  "Обновить запись в каталоге entry выполнив изменения changes. Если количество записей длинного имени для новой записи отличается, то записи длинного имени и запись в каталоге будет пересоздана"
  (let ((new-entry (copy-tree entry))
        (lfn-count-old (fat32-calc-lfn-count (get-hash entry 'name)))
        (entry-pos (fat32-find-entry-pos entry))
        (changes-copy changes))
    (while (not (null changes-copy))
      (set-hash new-entry (caar changes-copy) (cdar changes-copy))
      (setq changes-copy (cdr changes-copy)))
    (let ((lfn-count-new (fat32-calc-lfn-count (get-hash new-entry 'name)))
          (dir-stream (make-instance 'File))
          (byte-array nil))
      (File-set-size dir-stream (* *block-size* (list-length (get-fat-chain (get-hash entry 'first-block)))))
      (File-set-position dir-stream entry-pos)
      (File-set-blocks dir-stream (get-fat-chain (get-hash entry 'parent-first-block)))
      (if (!= lfn-count-new lfn-count-old)
          (progn
            (setq byte-array (fat32-create-lfn-dir-entries new-entry))
            (fat32-mark-for-delete entry)
            (File-set-position dir-stream (fat32-get-free-entry-pos
                                           (get-hash entry 'parent-first-block)
                                           (/ (array-size byte-array) 32)))
            (write-file dir-stream byte-array))
          (progn
            (setq byte-array (fat32-create-dir-entry new-entry))
            (write-file dir-stream byte-array)))
      (while (not (null changes))
        (set-hash entry (caar changes) (cdar changes))
        (setq changes (cdr changes))))))

(defun fat32-add-entry (entry)
  "Добавление записи entry на диск"
  (let ((new-entry (copy-tree entry))
        (lfn-count (fat32-calc-lfn-count (get-hash entry 'name)))
        (dir-stream (make-instance 'File))
        (byte-array nil))
    (File-set-size dir-stream (* *block-size* (list-length (get-fat-chain (get-hash entry 'first-block)))))
    (File-set-blocks dir-stream (get-fat-chain (get-hash entry 'parent-first-block)))
    (setq byte-array (fat32-create-lfn-dir-entries new-entry))
    (File-set-position dir-stream (fat32-get-free-entry-pos
                                   (get-hash entry 'parent-first-block)
                                   (/ (array-size byte-array) 32)))
    (write-file dir-stream byte-array)
    (setq byte-array (fat32-create-dir-entry new-entry))
    (write-file dir-stream byte-array)))

(defun is-short-name-sym (symbol)
  "Проверка на символ короткой строки"
  (let ((code (char-code symbol))
        (special-chars '(#\! #\# #\$ #\% #\& #\' #\( #\) #\- #\@ #\^ #\_ #\` #\{ #\} #\~)))
    (or
     (and (>= code (char-code #\A)) (<= code (char-code #\Z)))
     (and (>= code (char-code #\0)) (<= code (char-code #\9)))
     (contains special-chars symbol)
     (and (>= code 128) (<= code 228))
     (and (>= code 230) (<= code 255)))))

(defun get-trail-num (dir-entries short-name)
  "Получить номер числового хвоста для короткого имени short-name"
  (let ((trail-num 1))
    (while (not (null dir-entries))
      (let ((entry-short-name (car (split #\. (get-hash (car dir-entries) 'short-name))))
            (base-name nil))
        (setq base-name (car (split #\~ entry-short-name)))
        (when (<= (string-size base-name) (string-size short-name))
          (when (equal base-name (subseq short-name 0 (string-size base-name)))
            (incf trail-num)))
        (setq dir-entries (cdr dir-entries))))
    trail-num))

(defun fat32-generate-short-name (dir long-name)
  "Сгенерировать короткое имя из длинного имени long-name в каталоге dir"
  (let ((short-name "")
        (short-name2 "")
        (long-name (split #\. long-name))
        (long-name1 "")
        (long-name2 ""))
    (if (>= (list-length long-name) 2)
        (progn
          (while (not (null (cdr long-name)))
            (setq long-name1 (concat long-name1 (car long-name)))
            (setq long-name (cdr long-name)))
          (setq long-name2 (car long-name)))
        (setq long-name1 (car long-name)))
    (for i 0 (string-size long-name1)
         (sets long-name1 i (toupper (char long-name1 i))))
    (for i 0 (string-size long-name2)
         (sets long-name2 i (toupper (char long-name2 i))))
    (for i 0 8
         (when (< i (string-size long-name1))
           (setq short-name (concat short-name
                                    (make-string 1 (if
                                                    (is-short-name-sym (char long-name1 i))
                                                    (char long-name1 i)
                                                    #\_))))))
    (for i 0 3
         (when (< i (string-size long-name2))
           (setq short-name2 (concat short-name2
                                     (make-string 1 (if
                                                     (is-short-name-sym (char long-name2 i))
                                                     (char long-name2 i)
                                                     #\_))))))
    (let ((num-trail (concat "~" (inttostr (get-trail-num (car (get-hash dir 'dir)) short-name)))))
      (if (> (+ (string-size short-name) (string-size num-trail)) 8)
          (setq short-name (concat (subseq short-name 0 (- 8 (string-size num-trail))) num-trail))
          (setq short-name (concat short-name num-trail))))
    (when (!= (string-size short-name2) 0)
      (setq short-name (concat (concat short-name ".") short-name2)))
    short-name))
